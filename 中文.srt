1
00:00:02,159 --> 00:00:04,399
great

2
00:00:04,560 --> 00:00:08,160
接下来我会从一些基础的东西讲起

3
00:00:08,160 --> 00:00:13,759
这样其他朋友们看到我发的tweet进来（直播）的时候

4
00:00:13,759 --> 00:00:14,960
也不会错过太多内容

5
00:00:14,960 --> 00:00:18,080
如果你之前已经安装过rust的话

6
00:00:18,080 --> 00:00:21,840
接下来的应该对你难度不大

7
00:00:21,840 --> 00:00:23,840
yeah 我接下来想谈一点

8
00:00:23,840 --> 00:00:28,000
关于rust的安装以及上手

9
00:00:28,000 --> 00:00:30,000
装好需要的一些工具，并且能运行起来

10
00:00:30,000 --> 00:00:33,520
当你把需要的东西装上并跑起来以后

11
00:00:33,520 --> 00:00:35,200
你就可以和我一起play起来了

12
00:00:35,200 --> 00:00:36,719
如果你已经完成了相关的安装，别担心


14
00:00:38,640 --> 00:00:42,000
讲完这些不会花太多时间的

15
00:00:42,000 --> 00:00:46,079
我们要去的第一个地方是 rustup.rs

16
00:00:46,079 --> 00:00:49,600
rustup.rs 就是一个简单的网站

17
00:00:49,600 --> 00:00:52,239
它会检测你使用的电脑

18
00:00:52,239 --> 00:00:54,800
还有现在你在用的操作系统

19
00:00:54,800 --> 00:00:58,399
之后会显示一行脚本给你

20
00:00:58,399 --> 00:01:01,440
你可以运行它来安装rustup

21
00:01:01,440 --> 00:01:05,360
在百分之90的情况下这就是你想要的


23
00:01:05,360 --> 00:01:08,479
如果你用的是特殊的linux发行版

24
00:01:08,479 --> 00:01:12,240
有一些特殊的安装要求，可能会遇到困难

25
00:01:12,240 --> 00:01:16,799
你应该按你的linux发行版安装软件的方法去做


27
00:01:16,799 --> 00:01:20,720
我现在用的操作系统是nix os 

29
00:01:20,720 --> 00:01:25,680
正好 nix 就是一个有特别的安装方法的系统

41
00:01:25,680 --> 00:01:29,360
我很高兴能分享我的方法，如果有谁也在用nix os

43
00:01:29,360 --> 00:01:32,799
我可以分享我的nix shell

44
00:01:32,799 --> 00:01:40,479
但是总的来说，你访问 rustup.rs之后

46
00:01:40,479 --> 00:01:42,640
你应该就能直接复制粘贴然后把rust安装上了

47
00:01:42,640 --> 00:01:44,880
我已经安装好了这些

48
00:01:44,880 --> 00:01:47,119
我只是想要给大家展示一下rustup.rs

49
00:01:47,119 --> 00:01:49,360
如果之前没见过的话

50
00:01:49,360 --> 00:01:52,640
在windows上 在mac上

51
00:01:52,640 --> 00:01:54,079
还有大多数linux发行版上

52
00:01:54,079 --> 00:02:00,079
这是安装rust的一个好选择

55
00:02:00,240 --> 00:02:04,079
我之后会用vs code

56
00:02:04,079 --> 00:02:06,479
我相信大家都有安装了

57
00:02:06,479 --> 00:02:08,720
至少也听说过

58
00:02:08,720 --> 00:02:11,440
如果你还没有安装它

59
00:02:11,440 --> 00:02:14,400
这并不是唯一的

60
00:02:14,400 --> 00:02:16,239
你可以使用的工具

61
00:02:16,239 --> 00:02:17,760
应该说不是唯一的ide

62
00:02:17,760 --> 00:02:21,120
你可以安装以后用来编辑

63
00:02:21,120 --> 00:02:23,520
rust代码的，但它用起来

64
00:02:23,520 --> 00:02:24,160
挺好

65
00:02:24,160 --> 00:02:26,480
就像我说的，我将会使用它

66
00:02:26,480 --> 00:02:27,599
告诉你如何设置

67
00:02:27,599 --> 00:02:30,720
vs code 但我也想提一下

68
00:02:30,720 --> 00:02:37,840
还有 intellij rust

69
00:02:43,360 --> 00:02:46,560
这也是另一个适合人们使用的好工具

70
00:02:46,560 --> 00:02:46,879
that

71
00:02:46,879 --> 00:02:51,840
你知道也许他们更喜欢intellij风格


73
00:02:52,080 --> 00:02:54,560
我已经用过几次了，有人告诉我说

74
00:02:54,560 --> 00:02:56,319
它非常好的

75
00:02:56,319 --> 00:02:58,560
我应该首先向大家推荐的

77
00:02:58,560 --> 00:03:01,519
而不是推荐我自己的设置，所以

78
00:03:01,519 --> 00:03:02,480
你知道

79
00:03:02,480 --> 00:03:05,120
无论哪种，你知道也许可以同时尝试，或者如果

80
00:03:05,120 --> 00:03:06,159
你看一下

81
00:03:06,159 --> 00:03:08,959
嗯，两个网站，看看哪一个感觉

82
00:03:08,959 --> 00:03:10,080
对你来说更好

83
00:03:10,080 --> 00:03:13,519
更符合你已经习惯的工作流

85
00:03:13,519 --> 00:03:15,440
关于intellij的一个好东西是

86
00:03:15,440 --> 00:03:16,840
intellij

87
00:03:16,840 --> 00:03:20,800
rust ide support

88
00:03:20,800 --> 00:03:23,120
是，它实际上是相当

89
00:03:23,120 --> 00:03:24,640
复杂，所以他们有像

90
00:03:24,640 --> 00:03:25,920
重构

91
00:03:25,920 --> 00:03:28,879
他们有相当好的静态分析

92
00:03:28,879 --> 00:03:30,640
宏扩展

93
00:03:30,640 --> 00:03:31,840
我不打算顺便说一下，我不打算

94
00:03:31,840 --> 00:03:33,680
谈论宏的问题，这是

95
00:03:33,680 --> 00:03:34,319
更

96
00:03:34,319 --> 00:03:38,000
关注初学者的视频，但如果你开始深入

98
00:03:38,000 --> 00:03:40,239
Rust更认真一些的时候，你会想

99
00:03:40,239 --> 00:03:42,239
你就会希望有一些东西能帮助你处理这些问题。

100
00:03:42,239 --> 00:03:43,360
宏，因为它是

101
00:03:43,360 --> 00:03:47,519
这绝对是语言中的一个领域

103
00:03:47,519 --> 00:03:51,760
开发相关工具很吃力，因此

105
00:03:51,760 --> 00:03:54,159
调试你的宏和其他东西也

106
00:03:54,159 --> 00:03:56,000
往往要花很多时间，所以任何你能找到的

107
00:03:56,000 --> 00:03:58,239
工具支持

108
00:03:58,239 --> 00:04:01,599
真的很有帮助，它有自动完成功能

109
00:04:01,599 --> 00:04:04,560
我们在vs code插件中也一样会看到

111
00:04:04,560 --> 00:04:08,720
但是，嗯，任何这些

112
00:04:08,720 --> 00:04:10,720
跳出来的功能，冉你感觉

113
00:04:10,720 --> 00:04:12,239
是的，我真的很想

114
00:04:12,239 --> 00:04:15,360
我真的很喜欢其中的一些功能

115
00:04:15,360 --> 00:04:19,918
假设你用了几个星期Rust

117
00:04:19,918 --> 00:04:22,320
然后你就会想，我真的很希望我的Ide能做这个

119
00:04:22,320 --> 00:04:24,880
也许intellij就是你的理想选择。

120
00:04:24,880 --> 00:04:27,759
所以我只想提一嘴

121
00:04:27,759 --> 00:04:30,160
因为可能你想要的东西

122
00:04:30,160 --> 00:04:33,919
与我正在使用的设置有一点不同


124
00:04:34,000 --> 00:04:37,199
但这是我会用到的设置
 

126
00:04:37,199 --> 00:04:40,560
如果你想和我一起玩耍一下

127
00:04:40,560 --> 00:04:43,520
所以我已经安装了 VS Code

128
00:04:43,520 --> 00:04:46,880
但我要告诉你之后的步骤

129
00:04:47,520 --> 00:04:51,520
dog jones提到了Clion

131
00:04:51,520 --> 00:04:55,280
CLion是另一个你可以用的Ide

133
00:04:55,280 --> 00:04:58,479
有一个Rust插件可以下载

135
00:04:58,479 --> 00:05:02,720
所以你知道的， 只要你觉得用着顺手就行。

137
00:05:02,720 --> 00:05:04,000
就是随便到处点一点， 看看有什么功能

138
00:05:04,000 --> 00:05:06,080
并找到设置

139
00:05:06,080 --> 00:05:09,520
对， 所以浏览器里面的内容还有什么可说的吗

141
00:05:09,520 --> 00:05:12,960
在我们开整之前 ，让我想想

142
00:05:12,960 --> 00:05:16,560
我觉得这样好， 我就把浏览器开着挂在后台吧

144
00:05:16,560 --> 00:05:18,240
所以我们可以在需要时跳回它 

145
00:05:18,240 --> 00:05:21,440
但我现在要把它隐藏起来

147
00:05:21,440 --> 00:05:25,840
找个地方放一下

148
00:05:26,160 --> 00:05:30,639
所以我们现在是在 VS Code 中

149
00:05:31,120 --> 00:05:33,600
嗯，我已经设置好了VS Code

150
00:05:33,600 --> 00:05:34,800
但我要告诉你如何设置VS Code

151
00:05:34,800 --> 00:05:37,520
好让你知道

152
00:05:37,520 --> 00:05:40,720
比方说，这是一个新的安装

153
00:05:40,720 --> 00:05:42,400
我进入它的第一件事是

154
00:05:42,400 --> 00:05:48,880
我将点击这个左手边写着 "扩展 "的地方。

157
00:05:48,880 --> 00:05:53,840
然后我将在顶部搜索 "rust"

158
00:05:54,080 --> 00:05:58,479
现在，当你这样做时，会看到好多搜索结果

160
00:05:58,479 --> 00:06:00,880
你注意到， 至少前两个 

161
00:06:00,880 --> 00:06:04,880
有相当多的下载数量

163
00:06:04,880 --> 00:06:08,319
你知道超过10 000， 所以真的

164
00:06:08,319 --> 00:06:10,560
这两个里你可以选一个安装 

165
00:06:10,560 --> 00:06:14,639
我倾向于使用的是名为 Rust Analyzer 的插件。

167
00:06:14,639 --> 00:06:22,800
Rust Analyzer 是一种拓展的Ide支持

169
00:06:22,800 --> 00:06:26,400
所以它不一定是作为 rust 的一部分来打包的

171
00:06:26,400 --> 00:06:28,800
但当你安装这个插件

172
00:06:28,800 --> 00:06:32,240
它将会下载一个扩展包， 这将是 rust analyzer服务器 的二进制包

174
00:06:32,240 --> 00:06:36,639
然后这将在你的系统的后台运行

176
00:06:36,639 --> 00:06:40,160
而 rust analyzer 插件会与跑在本地的 rust analyzer服务器 通信 

178
00:06:40,800 --> 00:06:44,160
然后给你

179
00:06:44,160 --> 00:06:47,199
提供相应的Ide的支持 

180
00:06:47,199 --> 00:06:49,360
我们会看到， 随着我们往下走

181
00:06:49,360 --> 00:06:50,479
但 rust analyzer 是我要推荐的

183
00:06:52,479 --> 00:06:55,520
我们可以看到， 现在它是pre1.0版本，

184
00:06:55,520 --> 00:06:57,759
所以你可能会发现，每一次在一段时间内

185
00:06:57,759 --> 00:06:59,280
你可能需要重新启动它或其他什么来保持它的运行 


188
00:07:04,560 --> 00:07:06,560
但我发现它对于小型项目。

189
00:07:06,560 --> 00:07:08,080
还有中等规模的项目

190
00:07:08,080 --> 00:07:11,199
呃......它往往是无懈可击的

191
00:07:11,199 --> 00:07:12,880
当你进入真正的大项目时

192
00:07:12,880 --> 00:07:14,720
然后它就好像每隔一段时间就会出点小问题，你得重启一下什么的
 
194
00:07:15,039 --> 00:07:16,240
在这种大项目上稍微有点痛苦了有时候

195
00:07:16,240 --> 00:07:17,919
但我想说的是，基本上

196
00:07:17,919 --> 00:07:19,280
这是一个相当可靠的

197
00:07:19,280 --> 00:07:22,319
在起步阶段这是个相当可靠的插件

198
00:07:22,319 --> 00:07:23,919
所以我已经安装了，你看 

199
00:07:23,919 --> 00:07:25,919
我这里没有安装的按钮

200
00:07:25,919 --> 00:07:32,880
所以一旦安装完毕，它就会去获取 Rust语言服务器。

203
00:07:32,880 --> 00:07:34,720
额， 不对是Rust Analyzer服务器， Rust language 服务器是以前用的了

205
00:07:36,960 --> 00:07:39,360
一旦安装了Rust Analyzer， 它就会在后台运行。

207
00:07:40,160 --> 00:07:42,240
然后它可能会让你重新启动VS Code

208
00:07:42,240 --> 00:07:43,360
或类似的操作

209
00:07:43,360 --> 00:07:44,800
一旦它被重新启动，你的环境

210
00:07:44,800 --> 00:07:48,879
就和我现在的一样了

211
00:07:48,879 --> 00:07:52,479
所以现在， 你已经装上了rustup

212
00:07:52,479 --> 00:07:55,520
然后 rustup 会提供给你

213
00:07:55,520 --> 00:07:58,960
rust编译器和与之配套的一系列工具

215
00:07:58,960 --> 00:08:02,720
我们已经得到了Ide支持，通过

216
00:08:02,720 --> 00:08:04,400
你知道的 安装VS Code和rust analyzer 

217
00:08:04,400 --> 00:08:07,360
这两个安装操作

218
00:08:07,360 --> 00:08:09,120
你需要跟着我完成的

219
00:08:09,120 --> 00:08:11,120
这样才能跟着我继续下面的直播

221
00:08:12,560 --> 00:08:15,919
嗯，好的，一旦装好了rust analyzer

223
00:08:17,440 --> 00:08:20,000
你需要做的配置真的不多。

225
00:08:20,720 --> 00:08:23,360
呃，让我们看看，我是不是在骗你？

226
00:08:23,360 --> 00:08:25,280
让我快速检查一下

227
00:08:25,280 --> 00:08:32,000
我正在努力回忆是否有任何设置， 我做了什么？

229
00:08:32,000 --> 00:08:35,760
可能与默认值有不同的。

230
00:08:36,080 --> 00:08:39,679
嗯，我确实要确保

231
00:08:39,679 --> 00:08:43,440
启用了保存时的检查（check on save）

232
00:08:43,440 --> 00:08:48,480
所以每次我保存

234
00:08:48,800 --> 00:08:52,000
每次我保存这个项目时 

235
00:08:52,000 --> 00:08:54,880
然后它就会在后台重建。

236
00:08:54,880 --> 00:08:55,920
它将重新检查这个项目

237
00:08:55,920 --> 00:08:58,320
然后给我任何错误和其他东西 

238
00:08:58,320 --> 00:09:00,560
所以我更喜欢它在每次保存时进行检查。

240
00:09:03,839 --> 00:09:05,920
我想另一件事是，我通常会检查

242
00:09:07,440 --> 00:09:10,160
和默认情况不同的是

244
00:09:10,720 --> 00:09:13,680
是格式

245
00:09:14,320 --> 00:09:17,760
是的，我检查了这个

246
00:09:17,760 --> 00:09:21,519
这也是VS Code特有的设置

247
00:09:21,519 --> 00:09:23,040
intellij可能有不同的设置

248
00:09:23,040 --> 00:09:25,279
但在vs code中， 我开启了自动格式化

249
00:09:25,279 --> 00:09:27,600
我们点击这个

250
00:09:27,600 --> 00:09:30,800
原因是

251
00:09:30,800 --> 00:09:32,480
虽然这个直播里不会仔细讲

252
00:09:32,480 --> 00:09:34,560
但其中有一件事， 随着rustup安装的一个东西是

254
00:09:36,399 --> 00:09:39,839
rust的格式化工具（rust formmater）


256
00:09:40,880 --> 00:09:43,440
这给了Rust代码一个标准的格式


258
00:09:44,399 --> 00:09:47,680
所以它更容易阅读，

259
00:09:47,680 --> 00:09:50,959
更容易审阅，就像如果你要发送一个PR

260
00:09:50,959 --> 00:09:53,519
大多数经常用Rust的人都会

261
00:09:53,519 --> 00:09:55,200
习惯了rust的格式

262
00:09:55,200 --> 00:09:57,600
标准的Rust格式

264
00:09:57,600 --> 00:10:00,320
所以我肯定会建议你选上这个，这样每一次你保存的时候

265
00:10:00,320 --> 00:10:02,240
它就会重新格式化你的代码

266
00:10:02,240 --> 00:10:04,640
顺便说一下，呃，其中一个好东西

267
00:10:04,640 --> 00:10:05,360
关于这个自动格式化

268
00:10:05,360 --> 00:10:07,760
是如果它没有格式化你的代码

269
00:10:07,760 --> 00:10:09,200
当你点击保存的时候

270
00:10:09,200 --> 00:10:12,720
那么一种情况可能是解析器的问题

271
00:10:12,720 --> 00:10:15,440
另一种就是你代码里有错误

272
00:10:15,440 --> 00:10:16,640
有点像是提醒你哪里写错了

273
00:10:16,640 --> 00:10:19,040
我需要关闭一个括号

274
00:10:19,040 --> 00:10:21,519
我需要在某个地方关闭它的圆括号

275
00:10:21,519 --> 00:10:24,720
一旦你这样做了，它就会顺利格式化了

276
00:10:24,720 --> 00:10:26,640
你就感觉， 好， 至少没有明显的语法错误了。

277
00:10:26,640 --> 00:10:33,120
现在我可以让剩下的部分继续下去了


279
00:10:33,120 --> 00:10:36,480
是的，所以安迪提到了这一点

280
00:10:36,480 --> 00:10:39,040
要确保你安装（rust官方插件和rust analyzer）其中一个

281
00:10:39,040 --> 00:10:40,880
我认为这是个好主意

282
00:10:40,880 --> 00:10:43,279
所以你可以选一个试一试

283
00:10:43,279 --> 00:10:45,519
如果不喜欢它，先把它卸载掉

284
00:10:45,519 --> 00:10:48,640
然后再安装另一个

285
00:10:48,640 --> 00:10:51,279
不要像是点了这个的安装然后又继续点另一个

286
00:10:51,279 --> 00:10:52,480
安装 安装 安装

287
00:10:52,480 --> 00:10:54,480
然后希望它工作，因为有些

288
00:10:54,480 --> 00:10:57,040
其中有重叠的功能

289
00:10:57,040 --> 00:10:59,279
所以如果你同时运行它们，它们会发生冲突

290
00:10:59,279 --> 00:11:00,560
在同一时间

291
00:11:00,560 --> 00:11:03,360
是的，这是个好问题

292
00:11:04,880 --> 00:11:06,640
其他可有可无的东西我都说了，我想

293
00:11:06,640 --> 00:11:08,640
这就是一般的

294
00:11:08,640 --> 00:11:11,360
这两个配置选项

295
00:11:11,360 --> 00:11:11,839
我会检查的

296
00:11:11,839 --> 00:11:13,519
确保它在保存的时候检查代码

297
00:11:13,519 --> 00:11:16,560
确保它在保存时进行格式化

298
00:11:16,560 --> 00:11:19,279
这让我能够有

299
00:11:19,279 --> 00:11:21,120
非常合理的信心

300
00:11:21,120 --> 00:11:23,200
我看到所有的实时错误和

301
00:11:23,200 --> 00:11:26,839
我的代码也被格式化了

302
00:11:26,839 --> 00:11:28,880
正确的

303
00:11:28,880 --> 00:11:33,440
所以doctrines问到编译的问题

304
00:11:33,440 --> 00:11:38,640
Rust的编译器创建了一个exe文件

305
00:11:38,640 --> 00:11:42,160
因为Rust是一种系统级编程语言

306
00:11:42,160 --> 00:11:45,200
所以我们说的是像C或C加加的东西。

308
00:11:45,200 --> 00:11:47,760
它确实是为编写

309
00:11:47,760 --> 00:11:51,920
真正利用你系统性能的应用程序程序而创造出来的

311
00:11:51,920 --> 00:11:55,279
所以当你建立一个rust的项目在

312
00:11:55,279 --> 00:11:58,639
比如说windows，你会得到一个应用程序

313
00:11:58,639 --> 00:12:02,240
级别的东西，这是一个EXE

314
00:12:02,399 --> 00:12:09,839
有一些方法，可能你也知道，不一定是编译成EXE

316
00:12:09,839 --> 00:12:11,519
正如其他人刚刚指出的那样

317
00:12:11,519 --> 00:12:13,120
cargo run 是另一个选择

318
00:12:13,120 --> 00:12:15,360
所以，让我们真正开始讨论一下

319
00:12:15,360 --> 00:12:17,440
一些随rust安装的工具

320
00:12:17,440 --> 00:12:22,000
因为我们在接下来将使用这些工具

322
00:12:22,000 --> 00:12:25,120
所以我首先要做的是

323
00:12:25,120 --> 00:12:27,040
对不起，有点早，我的喉咙有点

324
00:12:27,040 --> 00:12:29,760
还没睡醒

325
00:12:31,600 --> 00:12:34,240
所以我在我的源码目录中，我正在进行

326
00:12:34,240 --> 00:12:37,200
启动一个新的项目

327
00:12:37,200 --> 00:12:40,880
所以我们就把这个项目叫做嗯

328
00:12:40,880 --> 00:12:44,639
stream，所以在这个

329
00:12:44,639 --> 00:12:46,959
在这个命令行中，所以一旦我已经

330
00:12:46,959 --> 00:12:48,079
我已经运行了让rustup

331
00:12:48,079 --> 00:12:51,040
我已经安装了所有的工具，然后我

332
00:12:51,040 --> 00:12:52,800
可以运行这个 cargo 命令

333
00:12:52,800 --> 00:12:56,480
cargo是, 它是

334
00:12:56,480 --> 00:12:59,839
像一些不同的命令

335
00:12:59,839 --> 00:13:04,320
合并在一个命令中，它的工作是能够

336
00:13:04,320 --> 00:13:07,279
不仅仅是构建你的应用程序，所以它可以

337
00:13:07,279 --> 00:13:08,560
构建所有的rust

338
00:13:08,560 --> 00:13:11,680
嗯，所有的rust源代码，它也将

339
00:13:11,680 --> 00:13:14,720
去为你获取项目的依赖

340
00:13:14,720 --> 00:13:17,680
比方说，你依赖其他一些

341
00:13:17,680 --> 00:13:19,200
他们称它们为crate(rust库的名称)，

342
00:13:19,200 --> 00:13:22,320
你知道的就是一个模块，另一个组件

343
00:13:22,320 --> 00:13:24,000
在某处（比如crate.io或者github上）

344
00:13:24,000 --> 00:13:25,839
它将去安装并帮你构建它

345
00:13:25,839 --> 00:13:29,040
并让它准备好，这样它就可以链接到你的

347
00:13:29,040 --> 00:13:31,120
应用中

348
00:13:31,120 --> 00:13:34,959
它可以做 嗯，我想你也可以检查一下

349
00:13:34,959 --> 00:13:35,920
比如说

350
00:13:35,920 --> 00:13:38,720
像过时的依赖

351
00:13:38,720 --> 00:13:39,519
像这样的

352
00:13:39,519 --> 00:13:41,839
嗯，你还可以用插件扩展cargo，

353
00:13:41,839 --> 00:13:43,920
让它有更多的功能

354
00:13:43,920 --> 00:13:46,320
所以它是一个非常强大的工具，真的

355
00:13:46,320 --> 00:13:46,959
厉害

356
00:13:46,959 --> 00:13:49,519
某种程度上是处理开发中很多任务的的一个百宝箱

357
00:13:49,519 --> 00:13:50,079
你将会使用

358
00:13:50,079 --> 00:13:53,839
作为一个开发者，使用Rust进行开发

359
00:13:53,839 --> 00:13:56,240
然后这个我将要做的就是

360
00:13:56,240 --> 00:13:57,760
运行 cargo new

361
00:13:57,760 --> 00:13:59,680
这将会创建一个新的rust项目

362
00:13:59,680 --> 00:14:02,320
然后就得到了

363
00:14:02,320 --> 00:14:05,839
一个基本的模板，一个开始的项目

364
00:14:05,839 --> 00:14:06,959
将使用

365
00:14:06,959 --> 00:14:10,399
嗯，让我们继续下去，看看那个

366
00:14:11,440 --> 00:14:13,519
而我要做的是，我将打开

367
00:14:13,519 --> 00:14:17,839
我刚刚创建的项目，我将用vs code打开那个

369
00:14:17,839 --> 00:14:20,000
你会发现在vs code中，如果你不是

370
00:14:20,000 --> 00:14:21,199
熟悉它

371
00:14:21,199 --> 00:14:23,199
我没有打开任何项目文件或

372
00:14:23,199 --> 00:14:24,480
诸如此类的东西

373
00:14:24,480 --> 00:14:27,040
我所做的就是打开我的目录

374
00:14:27,040 --> 00:14:30,079
刚刚创建的 嗯

375
00:14:30,079 --> 00:14:32,240
有一种相当于我们的

376
00:14:32,240 --> 00:14:33,600
项目文件

377
00:14:33,600 --> 00:14:37,199
这就是这个cargo.toml

378
00:14:37,360 --> 00:14:41,199
所以你可以看到，嗯，这里

379
00:14:41,199 --> 00:14:44,160
我们在"stream package"里，这里是我的

380
00:14:44,160 --> 00:14:45,519
版本

381
00:14:45,519 --> 00:14:47,839
一切，呃，当你使用 cargo new的时候，

382
00:14:47,839 --> 00:14:49,120
它默认为

383
00:14:49,120 --> 00:14:52,399
0.1，让你知道，我想他们是

384
00:14:52,399 --> 00:14:53,760
让你从

385
00:14:53,760 --> 00:14:58,000
非常基本的版本开始

387
00:14:58,000 --> 00:15:00,720
当然还有像who i am和这个

388
00:15:00,720 --> 00:15:01,839
edition(rust编译器大版本，类似C++的 C++17，20之类的标识)

389
00:15:01,839 --> 00:15:06,240
是说你想要使用的Rust语言的版本

391
00:15:06,240 --> 00:15:09,839
在这个项目中，然后我们使用

392
00:15:09,839 --> 00:15:12,720
rust 2018，所以这是最新的（现在是2021了）

393
00:15:12,720 --> 00:15:14,880
rust的版本

394
00:15:14,880 --> 00:15:16,399
顺便说一下，今年晚些时候我相信

395
00:15:16,399 --> 00:15:18,399
将会有另一个版本问世

396
00:15:18,399 --> 00:15:19,839
所以，如果你看到这个变化

397
00:15:19,839 --> 00:15:22,720
今年晚些时候，这是因为你知道

398
00:15:22,720 --> 00:15:24,079
我们有一个新的版本

399
00:15:24,079 --> 00:15:28,880
会在语言中做出一些变动

401
00:15:29,360 --> 00:15:30,720
但如果你想跟上我的视频

402
00:15:30,720 --> 00:15:32,480
在新的rust版本的出来后

403
00:15:32,480 --> 00:15:35,120
如果你担心

404
00:15:35,120 --> 00:15:37,040
关于任何不兼容的问题，你可以直接

405
00:15:37,040 --> 00:15:39,040
设置edition到2018

406
00:15:39,040 --> 00:15:40,720
而我们在stream中所做的一切

407
00:15:40,720 --> 00:15:44,399
将在任何的时间都正常工作

408
00:15:45,839 --> 00:15:49,040
这个cargo.toml的另一部分是

409
00:15:49,040 --> 00:15:49,920
依赖的声明

410
00:15:49,920 --> 00:15:51,920
所以像我之前说的，你可以添加

411
00:15:51,920 --> 00:15:53,759
依赖关系到你的项目

412
00:15:53,759 --> 00:15:57,199
然后cargo会去获取它们

413
00:15:57,199 --> 00:15:58,800
并为你构建它们

414
00:15:58,800 --> 00:16:01,920
我们可能会增加一些，随着

415
00:16:01,920 --> 00:16:04,959
我们的项目继续进行

416
00:16:06,720 --> 00:16:09,600
然后，另外一个cargo new创建的东西是

417
00:16:09,600 --> 00:16:10,800
gitignore文件

418
00:16:10,800 --> 00:16:13,440
这很好，我想我们是与时俱进的

419
00:16:13,440 --> 00:16:14,000
你知道的

420
00:16:14,000 --> 00:16:17,199
我们正在使用git

421
00:16:17,199 --> 00:16:18,480
它说它将会忽略掉

422
00:16:18,480 --> 00:16:21,120
target目录，target目录将会存放

423
00:16:21,120 --> 00:16:23,680
所有的构建产物

424
00:16:23,680 --> 00:16:25,680
所以，一旦我打出 cargo build

425
00:16:25,680 --> 00:16:28,240
它就会把构建过程的东西都放到/target中,

426
00:16:28,240 --> 00:16:29,120
然后main.rs

427
00:16:29,120 --> 00:16:32,720
是它创建的最后一个东西

428
00:16:32,800 --> 00:16:36,480
而这是实际的rust代码

429
00:16:36,480 --> 00:16:39,120
好了，这就是我们的hello world，呃

430
00:16:39,120 --> 00:16:40,560
我们将在下面讨论这个问题

431
00:16:40,560 --> 00:16:44,560
等一下，我需要看两眼

433
00:16:45,199 --> 00:16:48,320
直播的弹幕

434
00:16:48,560 --> 00:16:51,120
rust up docs也很有帮助，因为它

435
00:16:51,120 --> 00:16:52,480
打开完整的

436
00:16:52,480 --> 00:16:55,040
由rustup保存在本地的rust文档

437
00:16:55,040 --> 00:16:56,399
谢谢你，安迪，这真是个有用的点。

439
00:16:57,279 --> 00:17:00,320
嗯，是的，其他的一些cargo的功能

440
00:17:00,320 --> 00:17:03,279
是，你可以打开

441
00:17:03,279 --> 00:17:04,959
文档

442
00:17:04,959 --> 00:17:08,640
你可以运行相当于一个java doc的程序

443
00:17:08,640 --> 00:17:10,799
在你的代码上，这样你就可以为你的

444
00:17:10,799 --> 00:17:11,839
rust代码添加文档（doc string）

445
00:17:11,839 --> 00:17:13,760
然后在它上面运行一个cargo命令，然后

446
00:17:13,760 --> 00:17:16,559
然后它将生成HTML文档

447
00:17:16,559 --> 00:17:19,679
基于你的文档注释

448
00:17:19,679 --> 00:17:20,880
在代码中

449
00:17:20,880 --> 00:17:24,000
而且你可以做测试，所以rust和cargo

450
00:17:24,000 --> 00:17:25,599
有内置的测试工具

451
00:17:25,599 --> 00:17:27,520
所以你可以使用 cargo test，

452
00:17:27,520 --> 00:17:30,840
它将会运行所有的测试，在你的

453
00:17:30,840 --> 00:17:33,840
应用里

454
00:17:35,360 --> 00:17:38,320
是的，很好，所以让我们来

455
00:17:38,320 --> 00:17:39,120
谈一谈

456
00:17:39,120 --> 00:17:42,880
这个hello world 嗯

457
00:17:43,200 --> 00:17:44,960
呃，这很有趣，因为第一件事

458
00:17:44,960 --> 00:17:46,160
我想说的是，我不打算

459
00:17:46,160 --> 00:17:48,480
马上讨论printline

460
00:17:48,480 --> 00:17:52,000
这和所有其他语言中的println差不多，

461
00:17:52,000 --> 00:17:56,880
但是， 我们是在main函数

462
00:17:56,880 --> 00:17:59,280
而这个 fn 是一个你会

463
00:17:59,280 --> 00:18:00,400
注意到的， 在rust中

464
00:18:00,400 --> 00:18:04,160
有......有......有一些缩写

465
00:18:04,160 --> 00:18:06,000
我想 fucntion 这个词实在

466
00:18:06,000 --> 00:18:07,840
太长了，不方便打出来

467
00:18:07,840 --> 00:18:11,280
所以他们使用fn，所以它说是函数

468
00:18:11,280 --> 00:18:14,080
main它没有参数，然后

469
00:18:14,080 --> 00:18:16,400
这里有一个代码块，它将运行

470
00:18:16,400 --> 00:18:18,480
而这个代码块确实调用了

471
00:18:18,480 --> 00:18:20,160
某种打印函数，

472
00:18:20,160 --> 00:18:20,960
伴随这个很奇怪的

473
00:18:20,960 --> 00:18:23,760
最后的感叹号，这是一个

474
00:18:23,760 --> 00:18:24,880
宏（macro）

475
00:18:24,880 --> 00:18:26,799
同样，我也不会深入讲这个

476
00:18:26,799 --> 00:18:28,320
在这个视频中

477
00:18:28,320 --> 00:18:30,160
但是，这允许它是一个有点

478
00:18:30,160 --> 00:18:31,840
比一般的函数更高级的

479
00:18:31,840 --> 00:18:35,039
它可以采取多于一个

480
00:18:35,039 --> 00:18:38,080
变量， 所以它是非常高级的功能

481
00:18:38,080 --> 00:18:39,440
它可以接受可变数量的

482
00:18:39,440 --> 00:18:41,600
参数，而唯一的方法是要做到这一点

483
00:18:41,600 --> 00:18:44,160
的唯一方法是使用一个宏，所以

484
00:18:44,160 --> 00:18:44,960
这就是

485
00:18:44,960 --> 00:18:49,120
这就是为什么println是一个宏的简短原因

487
00:18:49,120 --> 00:18:51,120
在这个例子中，尽管没有

488
00:18:51,120 --> 00:18:52,640
额外的参数

489
00:18:52,640 --> 00:18:54,320
它只是一般的形式，所以它其实接受

490
00:18:54,320 --> 00:18:57,600
n个参数

491
00:18:57,600 --> 00:18:59,280
好的，那么这将打印出Hello world

492
00:18:59,280 --> 00:19:01,360
让我们实际运行这个项目

493
00:19:01,360 --> 00:19:03,520
所以我们可以看到这有几种方法

494
00:19:03,520 --> 00:19:05,440
我们可以运行这个

495
00:19:05,440 --> 00:19:08,960
所以我可以通过在命令行输入cargo run来运行这个

496
00:19:08,960 --> 00:19:12,240
如果我这么做，它将会

497
00:19:12,240 --> 00:19:14,240
做的是它要构建它

498
00:19:14,240 --> 00:19:16,320
然后，一旦它完成了构建它

499
00:19:16,320 --> 00:19:17,520
它将为我运行它

500
00:19:17,520 --> 00:19:20,799
这是嗯，用于大量的调试工作

501
00:19:20,799 --> 00:19:24,000
场景，你知道的，你想调整

502
00:19:24,000 --> 00:19:25,919
你想要的东西，只是得到一个快速

503
00:19:25,919 --> 00:19:27,200
运行，看看是否

504
00:19:27,200 --> 00:19:30,240
是正确的，你知道你会使用很多

505
00:19:30,240 --> 00:19:32,640
的cargo run

506
00:19:32,640 --> 00:19:35,679
你也可以构建那些产物

507
00:19:35,679 --> 00:19:39,360
通过 cargo build

509
00:19:39,360 --> 00:19:41,200
你会注意到它已经是它的

510
00:19:41,200 --> 00:19:43,120
已经构建好了，所以那次cargo run只花了

511
00:19:43,120 --> 00:19:44,320
不到半秒钟的时间

512
00:19:44,320 --> 00:19:47,039
而这次是一百分之一秒的时间，因为这些

513
00:19:47,039 --> 00:19:50,400
产物是由cargo run构建的

514
00:19:50,400 --> 00:19:54,240
所有产物（二进制，依赖包的二进制，可执行文件等）都在/target目录中

515
00:19:54,240 --> 00:19:56,880
在这种情况下（cargo run），我建立了一个

516
00:19:56,880 --> 00:19:58,480
debug构建

517
00:19:58,480 --> 00:20:02,000
所以如果我们打开/target/debug，我们会看到

518
00:20:02,000 --> 00:20:02,880
有一个

519
00:20:02,880 --> 00:20:05,520
在目录中有个 stream

520
00:20:05,520 --> 00:20:07,039
同时有相当数量的其他东西

521
00:20:07,039 --> 00:20:08,080
rust的作用

522
00:20:08,080 --> 00:20:11,280
我想说的是， cargo 会为你构建

523
00:20:11,280 --> 00:20:12,559
你的examples和

524
00:20:12,559 --> 00:20:15,520
和你的依赖关系等，所以/target里

525
00:20:15,520 --> 00:20:17,200
有一堆其他的目录

526
00:20:17,200 --> 00:20:18,320
东西

527
00:20:18,320 --> 00:20:20,159
但我们真正关心的主要事情是

528
00:20:20,159 --> 00:20:21,760
是 stream这个二进制文件

529
00:20:21,760 --> 00:20:24,640
就在这里

530
00:20:24,799 --> 00:20:28,720
所以如果我运行这个/target/debug/stream

531
00:20:28,720 --> 00:20:32,159
我得到同样的结果，所以这就是

532
00:20:32,159 --> 00:20:35,200
如果在WINDOWS中，cargo构建的将是一个.exe文件

534
00:20:35,200 --> 00:20:37,840
在linux中，这只是一个可执行文件

535
00:20:37,840 --> 00:20:39,679
一个二进制

536
00:20:39,679 --> 00:20:42,640
在Mac OS里也是如此

537
00:20:46,640 --> 00:20:48,720
好吧，让我快速扫描弹幕看看

538
00:20:48,720 --> 00:20:51,280
如果有任何问题

539
00:20:51,280 --> 00:20:54,640
嗯，有一个

540
00:20:54,640 --> 00:20:56,640
哦，我想你没有谈到这个

541
00:20:56,640 --> 00:20:57,760
关于这个

542
00:20:57,760 --> 00:21:01,520
但你提醒了我，你可以做

543
00:21:01,520 --> 00:21:04,720
一种实时的构建

544
00:21:04,720 --> 00:21:07,600
开启一个实时构建活动，我正在尝试

545
00:21:07,600 --> 00:21:09,039
回忆这个是怎么做的

546
00:21:09,039 --> 00:21:11,440
我想有一个cargo插件可以用在这里

547
00:21:11,440 --> 00:21:12,880
在那里你可以

548
00:21:12,880 --> 00:21:15,600
你知道要求cargo保持运行和

549
00:21:15,600 --> 00:21:18,159
所以每当你保存时，它就会重新编译构建项目

550
00:21:18,159 --> 00:21:20,640
并给你返回结果

551
00:21:20,640 --> 00:21:22,000
如果我能想起这个插件的名字，我会

552
00:21:22,000 --> 00:21:24,400
迟些时候告诉你们

553
00:21:24,960 --> 00:21:28,000
好了，现在我们已经我们已经做了cargo run

555
00:21:28,000 --> 00:21:30,880
和cargo build，这就是真正的

556
00:21:30,880 --> 00:21:31,360
循环

557
00:21:31,360 --> 00:21:34,080
是我们要做很多事情的地方。

558
00:21:34,080 --> 00:21:35,600
我们的很多工作

559
00:21:35,600 --> 00:21:38,320
正如我所提到的，还有一些测试，所以我

560
00:21:38,320 --> 00:21:40,480
可以打出

561
00:21:40,480 --> 00:21:44,240
#[test]和

562
00:21:44,240 --> 00:21:48,640
my_test函数，我们将只是assert

563
00:21:48,640 --> 00:21:52,640
在这个特殊的情况下是true

564
00:21:52,799 --> 00:21:54,559
注意实际上呃，其中一件事

565
00:21:54,559 --> 00:21:58,480
我觉得vs code特别方便的是

566
00:21:58,480 --> 00:22:02,480
是，你知道我可以从vs code中运行

567
00:22:02,480 --> 00:22:05,039
我可以运行这个函数，所以它将

568
00:22:05,039 --> 00:22:06,640
构建并运行它

569
00:22:06,640 --> 00:22:10,000
酷，我也可以运行测试，所以它将

570
00:22:10,000 --> 00:22:11,760
构建并运行测试

571
00:22:11,760 --> 00:22:14,400
然后这就是cargo test的输出

572
00:22:14,400 --> 00:22:15,679
看起来像

573
00:22:15,679 --> 00:22:17,600
所以我已经得到了你知道它说运行一个

574
00:22:17,600 --> 00:22:19,600
测试并且通过了一个测试

575
00:22:19,600 --> 00:22:22,880
如果我把这里改成

576
00:22:22,880 --> 00:22:26,159
false然后运行测试

577
00:22:26,159 --> 00:22:28,240
它会编译然后说哦这个失败了

578
00:22:28,240 --> 00:22:31,520
它会告诉你哪一个失败了
579
00:22:31,919 --> 00:22:33,679
所以很多测试

580
00:22:33,679 --> 00:22:35,600
都是这种形式的

581
00:22:35,600 --> 00:22:39,280
这只是一种告诉rust

582
00:22:39,280 --> 00:22:42,480
这个函数属于测试套件的方法

583
00:22:42,480 --> 00:22:46,640 
而不是应用程序本身

585
00:22:46,640 --> 00:22:48,320
所以你可以这样标记你的测试

586
00:22:48,320 --> 00:22:50,000
然后当

587
00:22:50,000 --> 00:22:53,120 
当cargo编译它的时候它会知道

588 
00:22:53,120 --> 00:22:54,720
rust编译器会寻找

589
00:22:54,720 --> 00:22:56,320 
所有这些测试用例

590
00:22:56,320 --> 00:22:59,280 
然后把它们放到一个可执行文件里

591
00:22:59,280 --> 00:23:00,559 
运行然后测试

592
00:23:00,559 --> 00:23:09,200 
所有的测试给你

593
00:23:09,200 --> 00:23:10,559
我没有流文件

594
00:23:10,559 --> 00:23:13,120
可以在这里发截图吗

595
00:23:13,120 --> 00:23:16,720
当然可以啊

596
00:23:18,159 --> 00:23:21,600
我想我只是分享

597
00:23:21,600 --> 00:23:26,080
我的代码所以我可以在流之外点击它

599
00:23:27,440 --> 00:23:30,240
对了"cargo watch"谢谢你

600
00:23:30,240 --> 00:23:31,360
那是

601
00:23:31,360 --> 00:23:34,159
那个可以实时重建的

602
00:23:34,159 --> 00:23:34,559 
然后

603
00:23:34,559 --> 00:23:37,919 
检查结果的

604
00:23:37,919 --> 00:23:42,559 
当你保存的时候它会自动为你重建的

606 00:23:48,080 --> 00:23:51,279 好的那就是

607 00:23:51,279 --> 00:23:53,520 开始的部分我想到这里

608 00:23:53,520 --> 00:23:54,559 可能下一步要做的

609 00:23:54,559 --> 00:23:58,159 就是开始讲讲rust语言本身了

611 00:23:58,159 --> 00:24:00,640 所以我们已经有了一些基本的

613 00:24:00,640 --> 00:24:04,720 rust的知识我们可以你知道我们可以

614 00:24:04,720 --> 00:24:07,760 我们可以有点危险了吧

615 00:24:07,760 --> 00:24:10,640 我这次直播的计划是介绍一下

617 00:24:10,640 --> 00:24:12,559 rust的基础知识

618 00:24:12,559 --> 00:24:16,000 然后一旦我们了解了基础知识

620 00:24:16,000 --> 00:24:19,679 就开始展示如何

621 00:24:19,679 --> 00:24:22,080 稍微处理一下借用检查器

623 00:24:23,520 --> 00:24:27,279 为了达到那个点为了达到

624 00:24:27,279 --> 00:24:29,279 借用检查器的东西我想

625 00:24:29,279 --> 00:24:30,880 有些人会来看这个直播

626 00:24:30,880 --> 00:24:32,400 想知道我该怎么

627 00:24:32,400 --> 00:24:34,559 如何通过借用检查器

628 00:24:34,559 --> 00:24:36,159 所以我想谈谈这个但是我们

629 00:24:36,159 --> 00:24:40,640 需要先了解一些基础知识才能到达那个点

631 00:24:41,200 --> 00:24:43,039 好的那么有哪些基础知识

632 00:24:43,039 --> 00:24:45,039 我们需要讲讲呢，我列了一个清单

634 00:24:47,279 --> 00:24:49,600 关于rust的任何具体的基础知识

635 00:24:49,600 --> 00:24:51,039 就在评论里说出来吧

636 00:24:51,039 --> 00:24:52,720 我会尽量尽量抓住它们

637 00:24:52,720 --> 00:24:55,279 当它们出现的时候

638 00:24:55,440 --> 00:24:58,320 好的我们已经讲过了rustup

639 00:24:58,320 --> 00:25:00,799 我们已经讲过了cargo，analyzer

640 00:25:00,799 --> 00:25:04,640 或者rust analyzer和cargo和函数

641 00:25:04,640 --> 00:25:06,480 嗯让我们实际使用一些函数

642 00:25:06,480 --> 00:25:11,520 这样我们就可以看到函数在实践中是什么样子的

644 00:25:12,640 --> 00:25:14,380 那么让我们让我们做一些吧

645
00:25:14,380 --> 00:25:17,499
[Music]

646
00:25:17,600 --> 00:25:20,000
great

647
00:25:21,360 --> 00:25:24,720
and i'm kind of deciding in real time 

648
00:25:24,720 --> 00:25:28,400
how much of rust i need to show in the first example

650
00:25:28,400 --> 00:25:32,240
let's actually show

651
00:25:34,080 --> 00:25:36,000
let's start with numbers first 

652
00:25:36,000 --> 00:25:37,679
and then we'll go to strings 

653
00:25:37,679 --> 00:25:39,600
and the reason i'm starting with numbers first 

654
00:25:39,600 --> 00:25:43,760
is that strings are decidedly more complex

655
00:25:43,760 --> 00:25:46,640
and so let's build to that 

656
00:25:46,640 --> 00:25:49,360
i don't think they're so complex that you can't understand them 

658
00:25:49,360 --> 00:25:52,720
but there's a few more steps to them than to like a simple number

660
00:25:52,720 --> 00:25:55,360
so we'll start with the number first 

661
00:25:55,360 --> 00:25:57,840
and then

662
00:25:58,080 --> 00:26:00,159
we'll use this number and then we'll go from there

663
00:26:00,159 --> 00:26:01,600
so it's not end

664
00:26:01,600 --> 00:26:02,880
sorry i keep going back and forth

665
00:26:02,880 --> 00:26:06,960
between languages is64

666
00:26:07,120 --> 00:26:09,520
ides i gotta love them when they

667
00:26:09,520 --> 00:26:11,360
highlight and kind of warn me that i'm

668
00:26:11,360 --> 00:26:13,120
typing the wrong thing

669
00:26:13,120 --> 00:26:19,320
all right so we're gonna print um hello to number here

671
00:26:19,320 --> 00:26:25,840
and then i'll call the greet function from here

674
00:26:32,080 --> 00:26:35,440
all right let's get our terminal back

675
00:26:35,440 --> 00:26:39,600
bash there we go

676
00:26:39,600 --> 00:26:43,360
so what i've done here is created a new function

678
00:26:43,360 --> 00:26:51,520
and it's taking a number this is a assigned a 64-bit integer i-64

681
00:26:51,520 --> 00:26:53,039
and then i'm just using this as a

682
00:26:53,039 --> 00:26:54,880
parameter here you can see where i said

683
00:26:54,880 --> 00:26:56,320
earlier that print line

684
00:26:56,320 --> 00:26:58,640
you can use it to pass arbitrary number

685
00:26:58,640 --> 00:26:59,679
of parameters

686
00:26:59,679 --> 00:27:02,320
and that's really going to be based on

687
00:27:02,320 --> 00:27:03,679
what's in the string

688
00:27:03,679 --> 00:27:06,400
so this string says there's one argument

689
00:27:06,400 --> 00:27:08,159
that's going to get passed in

690
00:27:08,159 --> 00:27:10,320
and then just put it here just like a

691
00:27:10,320 --> 00:27:11,840
format string

692
00:27:11,840 --> 00:27:15,120
and then i pass in x

693
00:27:15,760 --> 00:27:19,440
so yeah the next thing

694
00:27:19,440 --> 00:27:22,640
that we should show off is

695
00:27:22,640 --> 00:27:24,240
okay let's just talk about strings let's

696
00:27:24,240 --> 00:27:26,159
get it away let's get it out of the way

697
00:27:26,159 --> 00:27:29,760
um so strings are

698
00:27:29,760 --> 00:27:33,200
there's two kinds of strings

699
00:27:33,200 --> 00:27:36,559
i guess you could say a string

700
00:27:36,559 --> 00:27:40,720
which is the like an array of characters

701
00:27:40,720 --> 00:27:45,200
uh ray of bytes in memory that will

702
00:27:45,200 --> 00:27:47,120
be the the string that's written out so

703
00:27:47,120 --> 00:27:49,360
the the hello to my number or hello

704
00:27:49,360 --> 00:27:50,320
world

705
00:27:50,320 --> 00:27:52,320
all right so that's a string of bytes

706
00:27:52,320 --> 00:27:54,080
that can be interpreted as characters to

707
00:27:54,080 --> 00:27:55,039
write to the screen

708
00:27:55,039 --> 00:27:58,559
right so that is a string

709
00:27:58,799 --> 00:28:03,360
so i'm going to make a string

710
00:28:03,360 --> 00:28:06,159
my greeting

711
00:28:06,880 --> 00:28:10,080
hello world

712
00:28:10,320 --> 00:28:12,240
and you'll see that this is something

713
00:28:12,240 --> 00:28:14,159
slightly different

714
00:28:14,159 --> 00:28:16,240
so this says anster we're gonna we're

715
00:28:16,240 --> 00:28:17,600
gonna get back we're gonna come back to

716
00:28:17,600 --> 00:28:18,480
that

717
00:28:18,480 --> 00:28:20,159
but before we do that i'm gonna do this

718
00:28:20,159 --> 00:28:22,240
first

719
00:28:22,240 --> 00:28:25,919
so what i've done is i've made a string

720
00:28:25,919 --> 00:28:29,679
this string i've said turn this string

721
00:28:29,679 --> 00:28:33,760
into a capital string capital s string

722
00:28:33,760 --> 00:28:35,200
and then i'm going to pass that into

723
00:28:35,200 --> 00:28:45,840
here string

724
00:28:45,840 --> 00:28:50,159
hello to hello world all right let's see

725
00:28:52,640 --> 00:28:55,760
all right so this string capital s

726
00:28:55,760 --> 00:28:56,960
string

727
00:28:56,960 --> 00:29:00,720
is living in the heap somewhere

728
00:29:00,720 --> 00:29:04,320
so i've got the memory that is for

729
00:29:04,320 --> 00:29:06,880
this particular function on the stack

730
00:29:06,880 --> 00:29:09,279
and then i've got the heap which is the

731
00:29:09,279 --> 00:29:12,640
memory i allocate from my application

732
00:29:12,640 --> 00:29:15,840
so string is living it's taking this

733
00:29:15,840 --> 00:29:17,279
turning it into something that's living

734
00:29:17,279 --> 00:29:19,600
on the heap and then

735
00:29:19,600 --> 00:29:23,919
i'm calling greet with that string

736
00:29:23,919 --> 00:29:27,840
there's also and stir

737
00:29:28,640 --> 00:29:30,960
which we saw a little bit earlier so if

738
00:29:30,960 --> 00:29:33,200
i take this off

739
00:29:33,200 --> 00:29:36,159
i get this version and this is just

740
00:29:36,159 --> 00:29:37,919
saying that there is a

741
00:29:37,919 --> 00:29:40,799
what's called a string slice there is

742
00:29:40,799 --> 00:29:41,360
two

743
00:29:41,360 --> 00:29:44,159
like a pointer and a length that points

744
00:29:44,159 --> 00:29:45,600
somewhere in memory

745
00:29:45,600 --> 00:29:48,320
who knows where we don't know where but

746
00:29:48,320 --> 00:29:49,760
we are going to

747
00:29:49,760 --> 00:29:52,840
point to that and then hand that

748
00:29:52,840 --> 00:29:54,000
information

749
00:29:54,000 --> 00:29:56,159
to the function and then it's going to

750
00:29:56,159 --> 00:29:58,960
to print this out

751
00:29:59,200 --> 00:30:03,440
so capital s string and and stir

752
00:30:03,440 --> 00:30:06,320
are the two ways that you'll see strings

753
00:30:06,320 --> 00:30:07,440
in russ code

754
00:30:07,440 --> 00:30:09,120
and i just want to show them here we'll

755
00:30:09,120 --> 00:30:10,799
see this ampersand

756
00:30:10,799 --> 00:30:14,240
later and we'll get to learn why it's

757
00:30:14,240 --> 00:30:15,279
ampersand stir

758
00:30:15,279 --> 00:30:17,279
and like what that kind of means but i

759
00:30:17,279 --> 00:30:19,200
just wanted to show the two styles of

760
00:30:19,200 --> 00:30:20,080
strings

761
00:30:20,080 --> 00:30:21,520
because when you're seeing rust code

762
00:30:21,520 --> 00:30:24,320
you'll see you'll see both styles

763
00:30:24,320 --> 00:30:27,760
depending on the situation

764
00:30:31,440 --> 00:30:34,880
yep all right so that's kind of

765
00:30:34,880 --> 00:30:36,000
functions

766
00:30:36,000 --> 00:30:39,279
um something that we haven't done

767
00:30:39,279 --> 00:30:44,559
is to see a result uh do we want to

768
00:30:44,559 --> 00:30:51,840
sure why not

769
00:30:55,840 --> 00:30:59,200
so we'll say this is let's say this is

770
00:30:59,200 --> 00:31:01,440
name

771
00:31:02,840 --> 00:31:04,880
jt

772
00:31:04,880 --> 00:31:08,799
and then we'll get our result which is

773
00:31:08,799 --> 00:31:12,799
that and then we'll print this to the

774
00:31:16,840 --> 00:31:19,840
screen

775
00:31:20,799 --> 00:31:24,559
and that needs to be

776
00:31:24,960 --> 00:31:28,799
can't find oh yeah oops name

777
00:31:28,799 --> 00:31:32,399
there you go incidentally

778
00:31:32,399 --> 00:31:37,120
um another pitch for ide is having

779
00:31:37,120 --> 00:31:38,960
having the live error checking and then

780
00:31:38,960 --> 00:31:40,720
you can hover and see what the errors

781
00:31:40,720 --> 00:31:41,600
are

782
00:31:41,600 --> 00:31:44,799
key all right so

783
00:31:44,799 --> 00:31:47,039
i i changed our example just a little

784
00:31:47,039 --> 00:31:50,320
bit so we can see a return value

785
00:31:50,320 --> 00:31:55,200
we see i've created a jt string

786
00:31:55,200 --> 00:31:58,159
anster technically i've passed that into

787
00:31:58,159 --> 00:31:59,519
a function called greet

788
00:31:59,519 --> 00:32:02,720
so that comes in format just it's like

789
00:32:02,720 --> 00:32:04,159
print line

790
00:32:04,159 --> 00:32:06,480
almost identical to print line but print

791
00:32:06,480 --> 00:32:08,159
line does the additional step of writing

792
00:32:08,159 --> 00:32:09,360
out to the screen

793
00:32:09,360 --> 00:32:11,840
format just creates a string from what

794
00:32:11,840 --> 00:32:13,760
you're giving it so it's kind of

795
00:32:13,760 --> 00:32:16,240
the same format that we're using for

796
00:32:16,240 --> 00:32:17,039
print line

797
00:32:17,039 --> 00:32:18,720
i pass an argument and it's going to

798
00:32:18,720 --> 00:32:20,480
create a string for us

799
00:32:20,480 --> 00:32:22,320
notice i haven't i didn't say return

800
00:32:22,320 --> 00:32:23,760
this is just muscle memory i could have

801
00:32:23,760 --> 00:32:25,279
said it this way

802
00:32:25,279 --> 00:32:28,880
and got the same answer

803
00:32:28,880 --> 00:32:31,919
but one of the quirks i guess you could

804
00:32:31,919 --> 00:32:33,760
say about rust

805
00:32:33,760 --> 00:32:36,640
is that you don't have to say return for

806
00:32:36,640 --> 00:32:37,600
the last thing

807
00:32:37,600 --> 00:32:40,640
in the function or the last the last

808
00:32:40,640 --> 00:32:43,039
expression that would be evaluated in a

809
00:32:43,039 --> 00:32:44,399
function

810
00:32:44,399 --> 00:32:46,480
you can just leave the return off and

811
00:32:46,480 --> 00:32:48,720
leave the semicolon off

812
00:32:48,720 --> 00:32:51,919
and the semicolon does matter if you

813
00:32:51,919 --> 00:32:53,600
leave the semicolon off and the return

814
00:32:53,600 --> 00:32:54,480
off

815
00:32:54,480 --> 00:32:56,880
it treats this value it'll run this

816
00:32:56,880 --> 00:32:57,840
value

817
00:32:57,840 --> 00:33:01,200
and then return the result of this

818
00:33:01,200 --> 00:33:04,000
so it's a slightly subtle but i also

819
00:33:04,000 --> 00:33:05,760
wanted to mention it because it is

820
00:33:05,760 --> 00:33:07,120
definitely something you will see in

821
00:33:07,120 --> 00:33:08,880
rust code in the wild

822
00:33:08,880 --> 00:33:10,240
is that people will leave off the

823
00:33:10,240 --> 00:33:12,240
semicolon and leave off the return

824
00:33:12,240 --> 00:33:14,559
and just assume that this last value

825
00:33:14,559 --> 00:33:17,840
will return from the function

826
00:33:18,480 --> 00:33:20,559
so this will create format creates

827
00:33:20,559 --> 00:33:23,840
capital s string so it's creating

828
00:33:23,840 --> 00:33:26,159
in the heap it's creating some string

829
00:33:26,159 --> 00:33:27,919
memory

830
00:33:27,919 --> 00:33:30,320
allocating it enough space to write out

831
00:33:30,320 --> 00:33:32,640
this this formatted string

832
00:33:32,640 --> 00:33:36,000
and then handing us back the um

833
00:33:36,000 --> 00:33:37,440
as we'll see and sending back the

834
00:33:37,440 --> 00:33:40,159
ownership of this capital string so the

835
00:33:40,159 --> 00:33:43,760
the the ability to own this thing and

836
00:33:43,760 --> 00:33:45,519
once we have the result i just go ahead

837
00:33:45,519 --> 00:33:47,120
and do what we did before i just print

838
00:33:47,120 --> 00:33:48,080
the result

839
00:33:48,080 --> 00:33:53,840
that we got

840
00:33:53,919 --> 00:33:57,039
are our macros like dunder methods

841
00:33:57,039 --> 00:34:00,480
in python um i'm not familiar enough

842
00:34:00,480 --> 00:34:02,320
with python to know what the similarity

843
00:34:02,320 --> 00:34:02,960
between

844
00:34:02,960 --> 00:34:06,080
rus methods or rust macros and

845
00:34:06,080 --> 00:34:09,679
dunder methods are sorry

846
00:34:11,599 --> 00:34:14,879
are gender methods related to being able

847
00:34:14,879 --> 00:34:15,839
to pass

848
00:34:15,839 --> 00:34:20,079
like a number of arguments

849
00:34:20,079 --> 00:34:21,599
like any number of arguments to the

850
00:34:21,599 --> 00:34:23,919
function

851
00:34:29,599 --> 00:34:31,520
all right so that is functions and

852
00:34:31,520 --> 00:34:33,119
function calls of course we can have

853
00:34:33,119 --> 00:34:34,639
like multiple parameters here

854
00:34:34,639 --> 00:34:37,760
so i could have had like a y um

855
00:34:37,760 --> 00:34:41,119
and then use the y in here so that kind

856
00:34:41,119 --> 00:34:42,800
of follows a pattern if you're used to

857
00:34:42,800 --> 00:34:44,159
other programming languages

858
00:34:44,159 --> 00:34:49,839
no surprises

859
00:34:51,119 --> 00:34:54,879
the next thing i want to talk about is

860
00:34:54,879 --> 00:34:56,399
so there's like a whole bunch of rust

861
00:34:56,399 --> 00:34:57,920
topics that we could go

862
00:34:57,920 --> 00:35:00,560
into i'm going to just kind of kind of

863
00:35:00,560 --> 00:35:00,960
touch

864
00:35:00,960 --> 00:35:03,920
on enough that we can then explore a

865
00:35:03,920 --> 00:35:05,200
little bit deeper

866
00:35:05,200 --> 00:35:07,040
but the next thing i want to talk about

867
00:35:07,040 --> 00:35:09,680
is structs

868
00:35:09,760 --> 00:35:12,640
so let's say the classic one that i

869
00:35:12,640 --> 00:35:13,359
always saw

870
00:35:13,359 --> 00:35:15,359
in programming books growing up was

871
00:35:15,359 --> 00:35:16,720
employee

872
00:35:16,720 --> 00:35:20,240
which sounds very corporate but uh sorry

873
00:35:20,240 --> 00:35:23,359
we got an employee we'll have the name

874
00:35:23,359 --> 00:35:24,480
of the employee

875
00:35:24,480 --> 00:35:28,640
we'll use string string tends to be

876
00:35:28,640 --> 00:35:31,920
easier to work with because there isn't

877
00:35:31,920 --> 00:35:33,040
any

878
00:35:33,040 --> 00:35:35,040
uh any additional ownership things we

879
00:35:35,040 --> 00:35:37,280
need to think about this ampersand

880
00:35:37,280 --> 00:35:40,160
and again i'm kind of foreshadowing this

881
00:35:40,160 --> 00:35:40,960
ampersand

882
00:35:40,960 --> 00:35:44,320
gives us a hint that there is more

883
00:35:44,320 --> 00:35:46,400
sophisticated lifetime stuff or

884
00:35:46,400 --> 00:35:48,079
ownership stuff going on underneath the

885
00:35:48,079 --> 00:35:49,200
surface

886
00:35:49,200 --> 00:35:51,119
string does not alright string is just a

887
00:35:51,119 --> 00:35:53,839
value it's pointing out into heap memory

888
00:35:53,839 --> 00:35:55,760
that's all we need

889
00:35:55,760 --> 00:35:58,320
and whoever has this owns this and

890
00:35:58,320 --> 00:36:00,960
that's nice and simple

891
00:36:00,960 --> 00:36:04,000
we'll have an id that's that's also

892
00:36:04,000 --> 00:36:08,720
a sure i-64

893
00:36:10,400 --> 00:36:13,359
so we can create um we can create an

894
00:36:13,359 --> 00:36:15,040
employee

895
00:36:15,040 --> 00:36:17,119
so let's do that i'm going to get rid of

896
00:36:17,119 --> 00:36:18,960
this greet function

897
00:36:18,960 --> 00:36:20,320
but we'll probably bring it back in a

898
00:36:20,320 --> 00:36:22,560
second but just for now

899
00:36:22,560 --> 00:36:25,280
keep it simple we can create an employee

900
00:36:25,280 --> 00:36:27,200
by saying employee

901
00:36:27,200 --> 00:36:30,160
equals now the first way that you can

902
00:36:30,160 --> 00:36:31,599
create it

903
00:36:31,599 --> 00:36:35,280
is to say employee and then

904
00:36:35,280 --> 00:36:38,800
open curly and then start writing values

905
00:36:38,800 --> 00:36:41,839
in at this point

906
00:36:43,920 --> 00:36:48,000
so stream urine here now

907
00:36:48,880 --> 00:36:52,839
and then we'll give an ide of 101

908
00:36:52,839 --> 00:36:55,920
sure notice when i hit save

909
00:36:55,920 --> 00:36:59,680
oh yeah that is two string

910
00:37:01,440 --> 00:37:03,680
when i hit save it did the reformat

911
00:37:03,680 --> 00:37:05,280
that's again because the vs code has

912
00:37:05,280 --> 00:37:06,320
that setting

913
00:37:06,320 --> 00:37:08,240
but it also is nice because i know that

914
00:37:08,240 --> 00:37:10,079
this parses correctly

915
00:37:10,079 --> 00:37:12,079
um and it reads a bit better now that

916
00:37:12,079 --> 00:37:13,760
it's formatted

917
00:37:13,760 --> 00:37:15,599
so i've created an employee we now have

918
00:37:15,599 --> 00:37:16,800
an employee

919
00:37:16,800 --> 00:37:19,200
it's got a name i'm using again the

920
00:37:19,200 --> 00:37:20,079
capital s

921
00:37:20,079 --> 00:37:22,560
form of string here so i use the dot to

922
00:37:22,560 --> 00:37:23,760
string so that converts

923
00:37:23,760 --> 00:37:27,520
this into a capital s string

924
00:37:27,520 --> 00:37:30,079
and then i give ide a number and i have

925
00:37:30,079 --> 00:37:31,119
an employee

926
00:37:31,119 --> 00:37:33,440
you'll notice that once i do this i

927
00:37:33,440 --> 00:37:34,240
create a

928
00:37:34,240 --> 00:37:37,680
structure but i'm trying to print out

929
00:37:37,680 --> 00:37:40,640
the structure and and russ is like

930
00:37:40,640 --> 00:37:41,440
saying

931
00:37:41,440 --> 00:37:44,640
um you can't do that

932
00:37:44,640 --> 00:37:47,760
oh this is result let's try employee

933
00:37:47,760 --> 00:37:51,359
which will also be true that

934
00:37:51,359 --> 00:37:52,960
there's a whole bunch of gobbledygook

935
00:37:52,960 --> 00:37:54,880
things um

936
00:37:54,880 --> 00:37:57,119
but what it's trying to say in fact

937
00:37:57,119 --> 00:37:58,720
actually if we try to build down here i

938
00:37:58,720 --> 00:38:00,800
think we'll see it a little bit better

939
00:38:00,800 --> 00:38:03,680
one of the one of the things that vs

940
00:38:03,680 --> 00:38:04,160
code

941
00:38:04,160 --> 00:38:07,839
and internal ides struggle with is that

942
00:38:07,839 --> 00:38:10,960
when russ has a lot of information it

943
00:38:10,960 --> 00:38:13,119
doesn't necessarily format it well so if

944
00:38:13,119 --> 00:38:14,400
you see something that like

945
00:38:14,400 --> 00:38:17,520
in the hover is just it's just too much

946
00:38:17,520 --> 00:38:20,480
too much to parse go ahead and do the

947
00:38:20,480 --> 00:38:20,960
build

948
00:38:20,960 --> 00:38:22,560
on the command line if you want to get a

949
00:38:22,560 --> 00:38:25,599
little bit more information

950
00:38:25,599 --> 00:38:28,240
so this is saying a lot of stuff some of

951
00:38:28,240 --> 00:38:29,760
which we're going to talk about

952
00:38:29,760 --> 00:38:34,560
in a little bit later but um

953
00:38:34,560 --> 00:38:37,599
i just let's just quickly look at it so

954
00:38:37,599 --> 00:38:38,079
it's saying

955
00:38:38,079 --> 00:38:39,839
employee cannot be formatted with the

956
00:38:39,839 --> 00:38:41,760
default formatter

957
00:38:41,760 --> 00:38:43,119
and that kind of makes sense right we've

958
00:38:43,119 --> 00:38:44,880
got a format string

959
00:38:44,880 --> 00:38:48,880
it's saying take in this value

960
00:38:48,880 --> 00:38:50,720
and then just put it into the string and

961
00:38:50,720 --> 00:38:52,160
it's saying i don't know you've got a

962
00:38:52,160 --> 00:38:52,960
struct

963
00:38:52,960 --> 00:38:55,200
i need a string i have no idea how to

964
00:38:55,200 --> 00:38:58,079
turn your struct into a string

965
00:38:58,079 --> 00:39:00,079
and then there's some more information

966
00:39:00,079 --> 00:39:02,240
and as you get more advanced and rust

967
00:39:02,240 --> 00:39:03,920
this will kind of make sense it's saying

968
00:39:03,920 --> 00:39:05,760
you know there's certain things that you

969
00:39:05,760 --> 00:39:06,560
can

970
00:39:06,560 --> 00:39:09,440
certain definitions that you can create

971
00:39:09,440 --> 00:39:10,560
certain um

972
00:39:10,560 --> 00:39:12,720
traits as well we'll kind of look into

973
00:39:12,720 --> 00:39:14,160
traits here in a bit

974
00:39:14,160 --> 00:39:15,839
you know things that you can describe

975
00:39:15,839 --> 00:39:17,440
about your types

976
00:39:17,440 --> 00:39:20,960
so that russ can do more with them

977
00:39:20,960 --> 00:39:22,640
but we haven't done that yet we just

978
00:39:22,640 --> 00:39:24,079
made a struct

979
00:39:24,079 --> 00:39:27,119
and in making this direct

980
00:39:27,119 --> 00:39:29,440
well that's it there's not enough

981
00:39:29,440 --> 00:39:32,400
knowledge to actually print this out

982
00:39:32,400 --> 00:39:34,079
so there's a couple ways that we can

983
00:39:34,079 --> 00:39:35,520
handle this

984
00:39:35,520 --> 00:39:37,680
the first way is just to actually work

985
00:39:37,680 --> 00:39:39,520
with the fields themselves

986
00:39:39,520 --> 00:39:42,240
so i could say

987
00:39:42,640 --> 00:39:45,680
name and then

988
00:39:45,680 --> 00:39:48,720
dot name

989
00:39:49,119 --> 00:39:52,640
and once i hit save here let's go ahead

990
00:39:52,640 --> 00:39:55,280
and run this

991
00:39:55,680 --> 00:39:58,560
and then you see it says okay cool as

992
00:39:58,560 --> 00:39:59,839
long as i can reach

993
00:39:59,839 --> 00:40:03,359
into the structure and get to values

994
00:40:03,359 --> 00:40:03,760
that

995
00:40:03,760 --> 00:40:06,960
russ knows how to print then we're okay

996
00:40:06,960 --> 00:40:09,200
but the problem was actually having that

997
00:40:09,200 --> 00:40:10,880
whole structure it had no idea how to

998
00:40:10,880 --> 00:40:13,280
print that

999
00:40:14,160 --> 00:40:16,240
um yeah some of the comments andy points

1000
00:40:16,240 --> 00:40:18,079
out that there are different ways that

1001
00:40:18,079 --> 00:40:19,040
you can turn

1002
00:40:19,040 --> 00:40:22,880
one string into like a an and stir

1003
00:40:22,880 --> 00:40:25,359
into a string so there's like an

1004
00:40:25,359 --> 00:40:26,720
alternate method where you can say

1005
00:40:26,720 --> 00:40:29,839
string new and then pass in a string

1006
00:40:29,839 --> 00:40:30,720
like

1007
00:40:30,720 --> 00:40:35,200
hello and this does um

1008
00:40:35,200 --> 00:40:37,440
string from sorry not string new string

1009
00:40:37,440 --> 00:40:38,720
from

1010
00:40:38,720 --> 00:40:41,839
so this does the same thing as dot

1011
00:40:41,839 --> 00:40:42,640
tostring

1012
00:40:42,640 --> 00:40:44,720
just um you know matter of preference if

1013
00:40:44,720 --> 00:40:46,800
you prefer seeing it this way

1014
00:40:46,800 --> 00:40:53,839
definitely go for that

1015
00:40:59,040 --> 00:41:01,200
i have to be gentle with my water

1016
00:41:01,200 --> 00:41:03,040
there's like a cord for my microphone i

1017
00:41:03,040 --> 00:41:06,880
have to dodge around it okay

1018
00:41:06,880 --> 00:41:10,000
so we've reached into uh our string

1019
00:41:10,000 --> 00:41:12,640
our struct sorry our struct got the

1020
00:41:12,640 --> 00:41:13,760
string out

1021
00:41:13,760 --> 00:41:15,920
um we could do the same thing for ide

1022
00:41:15,920 --> 00:41:17,680
you'll notice i've got a little squiggle

1023
00:41:17,680 --> 00:41:20,240
rust is smart enough to know hey you've

1024
00:41:20,240 --> 00:41:22,000
used some of these fields but not all of

1025
00:41:22,000 --> 00:41:23,359
them

1026
00:41:23,359 --> 00:41:25,119
so that's pretty handy if you you need

1027
00:41:25,119 --> 00:41:26,480
to

1028
00:41:26,480 --> 00:41:28,640
find how to you know where you can

1029
00:41:28,640 --> 00:41:30,400
refactor your structs to remove stuff

1030
00:41:30,400 --> 00:41:34,480
that isn't getting used um

1031
00:41:34,480 --> 00:41:37,440
another way to print out the employee

1032
00:41:37,440 --> 00:41:39,920
and again this is a bit of foreshadowing

1033
00:41:39,920 --> 00:41:45,200
is that i can say derive debug

1034
00:41:45,359 --> 00:41:48,720
and i'll use a slightly different

1035
00:41:48,720 --> 00:41:51,760
format string here

1036
00:41:51,760 --> 00:41:53,839
and this is going to use what's called a

1037
00:41:53,839 --> 00:41:54,880
debug

1038
00:41:54,880 --> 00:41:58,240
format instead of a display format

1039
00:41:58,240 --> 00:42:00,480
a little bit in the weeds display is the

1040
00:42:00,480 --> 00:42:03,119
default and debug is

1041
00:42:03,119 --> 00:42:06,560
um more of an kind of an exploded view

1042
00:42:06,560 --> 00:42:08,000
into what you're looking at it's

1043
00:42:08,000 --> 00:42:11,280
intended like it says for debugging

1044
00:42:11,280 --> 00:42:15,200
so if i run this you'll see

1045
00:42:15,200 --> 00:42:18,640
um i see my greeting name of course now

1046
00:42:18,640 --> 00:42:19,920
it's not just the name it's the whole

1047
00:42:19,920 --> 00:42:20,880
thing

1048
00:42:20,880 --> 00:42:25,200
employee capital e employee semicolon or

1049
00:42:25,200 --> 00:42:28,720
curly and then the two fields

1050
00:42:28,720 --> 00:42:31,280
so if you're doing logging if you're

1051
00:42:31,280 --> 00:42:31,839
doing

1052
00:42:31,839 --> 00:42:36,000
print line debugging which i love

1053
00:42:36,000 --> 00:42:38,319
uh i'm a bit of old-school person i

1054
00:42:38,319 --> 00:42:39,920
don't really use the debugger that much

1055
00:42:39,920 --> 00:42:41,200
i do tend to use a lot of

1056
00:42:41,200 --> 00:42:43,680
print line debugging and then being able

1057
00:42:43,680 --> 00:42:44,240
to mark

1058
00:42:44,240 --> 00:42:47,119
structures as debug gives me the

1059
00:42:47,119 --> 00:42:49,440
opportunity to easily log them out or

1060
00:42:49,440 --> 00:42:51,200
easily print them to the screen

1061
00:42:51,200 --> 00:42:54,480
and see the contents um let me show you

1062
00:42:54,480 --> 00:42:54,880
one

1063
00:42:54,880 --> 00:42:57,440
one quick one this one's really nice so

1064
00:42:57,440 --> 00:42:58,800
this

1065
00:42:58,800 --> 00:43:02,240
magic spell it's like this cubert line

1066
00:43:02,240 --> 00:43:05,920
uh gives us a yet another way of doing

1067
00:43:05,920 --> 00:43:08,400
debug printing and this one's a little

1068
00:43:08,400 --> 00:43:09,680
bit nicer so it will

1069
00:43:09,680 --> 00:43:13,040
kind of pretty print out that value

1070
00:43:13,040 --> 00:43:15,520
for some for a small struct it's maybe

1071
00:43:15,520 --> 00:43:17,200
not as necessary you could kind of see

1072
00:43:17,200 --> 00:43:18,560
it on one line

1073
00:43:18,560 --> 00:43:20,240
but i found that as your structs get

1074
00:43:20,240 --> 00:43:22,240
bigger it's nice to kind of pretty print

1075
00:43:22,240 --> 00:43:27,839
them so you can see a little bit better

1076
00:43:29,680 --> 00:43:32,000
yeah so someone just asked are we gonna

1077
00:43:32,000 --> 00:43:33,359
go over dependencies yeah we'll

1078
00:43:33,359 --> 00:43:34,160
definitely

1079
00:43:34,160 --> 00:43:35,599
we'll definitely add some dependencies

1080
00:43:35,599 --> 00:43:37,280
to cargo tunnel so you can see what that

1081
00:43:37,280 --> 00:43:40,480
looks like in practice

1082
00:43:40,480 --> 00:43:43,680
they'll probably come a little bit later

1083
00:43:43,680 --> 00:43:45,760
all right so this is struxx being able

1084
00:43:45,760 --> 00:43:48,000
to define our structs and i kind of

1085
00:43:48,000 --> 00:43:48,720
hinted at

1086
00:43:48,720 --> 00:43:50,480
some new abilities that strucks will

1087
00:43:50,480 --> 00:43:52,839
have as we understand rust a little bit

1088
00:43:52,839 --> 00:43:54,640
better

1089
00:43:54,640 --> 00:43:56,960
these aren't required like you can start

1090
00:43:56,960 --> 00:43:58,800
more simply i just want to show like

1091
00:43:58,800 --> 00:43:59,599
once

1092
00:43:59,599 --> 00:44:02,319
you're at the point where you're like

1093
00:44:02,319 --> 00:44:02,960
well

1094
00:44:02,960 --> 00:44:04,560
i'm kind of stuck i don't know what's in

1095
00:44:04,560 --> 00:44:06,480
the structure i want to at least mention

1096
00:44:06,480 --> 00:44:08,560
the debug stuff so you can get

1097
00:44:08,560 --> 00:44:12,319
and get some interesting debug out of it

1098
00:44:13,680 --> 00:44:17,280
alright so we're back to this example

1099
00:44:19,200 --> 00:44:21,599
so that's structures in a nutshell

1100
00:44:21,599 --> 00:44:23,839
there's more

1101
00:44:23,839 --> 00:44:26,240
more to structures once we start talking

1102
00:44:26,240 --> 00:44:28,000
about traits or generics

1103
00:44:28,000 --> 00:44:30,880
but as the basic level of structs like

1104
00:44:30,880 --> 00:44:31,680
that's

1105
00:44:31,680 --> 00:44:34,839
that's abstract pretty plain and simple

1106
00:44:34,839 --> 00:44:37,200
um

1107
00:44:37,200 --> 00:44:40,480
do we want to talk about

1108
00:44:40,480 --> 00:44:42,400
yeah let's let's go ahead i've i kind of

1109
00:44:42,400 --> 00:44:43,599
made a list i'm going to stick to the

1110
00:44:43,599 --> 00:44:44,240
list

1111
00:44:44,240 --> 00:44:46,960
even though i'm tempted to to riff a bit

1112
00:44:46,960 --> 00:44:47,440
but let's

1113
00:44:47,440 --> 00:44:48,640
let's talk about the next thing on the

1114
00:44:48,640 --> 00:44:51,359
list which is enums

1115
00:44:51,359 --> 00:44:54,880
so we have employee and that is a way of

1116
00:44:54,880 --> 00:44:55,680
grouping

1117
00:44:55,680 --> 00:44:58,720
you know multiple fields and being able

1118
00:44:58,720 --> 00:44:59,680
to reference them

1119
00:44:59,680 --> 00:45:02,640
by like dotting into them another way

1120
00:45:02,640 --> 00:45:04,880
that you commonly structure your data

1121
00:45:04,880 --> 00:45:08,160
and ross is through an enum

1122
00:45:08,480 --> 00:45:10,640
so what would be a good example of an

1123
00:45:10,640 --> 00:45:12,319
enum

1124
00:45:12,319 --> 00:45:14,560
um

1125
00:45:15,599 --> 00:45:19,839
let's say

1126
00:45:21,920 --> 00:45:26,160
uh is true

1127
00:45:26,160 --> 00:45:30,319
equals true or false

1128
00:45:30,319 --> 00:45:33,839
okay hold on a second

1129
00:45:34,880 --> 00:45:38,720
i'm trying to think of like a good um

1130
00:45:39,440 --> 00:45:43,280
yeah let's do that so there's like true

1131
00:45:43,280 --> 00:45:46,240
false sorry for the what was that like

1132
00:45:46,240 --> 00:45:47,680
haskell or something

1133
00:45:47,680 --> 00:45:49,359
you can see that over the years i've

1134
00:45:49,359 --> 00:45:52,960
done way too many languages

1135
00:45:52,960 --> 00:45:54,319
all right what's our warning here oh

1136
00:45:54,319 --> 00:45:57,280
yeah it's never used

1137
00:45:57,359 --> 00:46:01,680
okay so we've got um an enum

1138
00:46:01,680 --> 00:46:04,000
and an enum is basically letting us talk

1139
00:46:04,000 --> 00:46:05,280
about

1140
00:46:05,280 --> 00:46:08,400
one of instead of being

1141
00:46:08,400 --> 00:46:10,240
all of these values like a struct is

1142
00:46:10,240 --> 00:46:11,839
like all of these fields is

1143
00:46:11,839 --> 00:46:15,920
one value an enum is one of these values

1144
00:46:15,920 --> 00:46:16,960
is the value

1145
00:46:16,960 --> 00:46:21,040
and you don't know until you ask

1146
00:46:21,839 --> 00:46:23,839
so let's look at what that looks like in

1147
00:46:23,839 --> 00:46:25,280
practice

1148
00:46:25,280 --> 00:46:29,200
so we have this is true enum

1149
00:46:29,200 --> 00:46:32,880
so we'll say my value equals

1150
00:46:32,880 --> 00:46:36,319
is true and you you notice instead of

1151
00:46:36,319 --> 00:46:39,520
dot we use colon colon does

1152
00:46:39,520 --> 00:46:40,800
whether you use dot or whether you use

1153
00:46:40,800 --> 00:46:43,119
colon colon there is kind of a rule

1154
00:46:43,119 --> 00:46:44,240
behind it

1155
00:46:44,240 --> 00:46:47,440
around is it a kind of a static value or

1156
00:46:47,440 --> 00:46:48,079
is it a

1157
00:46:48,079 --> 00:46:51,760
runtime thing i find that you're just

1158
00:46:51,760 --> 00:46:52,880
going to have to play with it a little

1159
00:46:52,880 --> 00:46:54,240
bit to get

1160
00:46:54,240 --> 00:46:57,920
the kind of the hunch of whether it's a

1161
00:46:57,920 --> 00:47:01,440
a dot dot a colon colon or a dot

1162
00:47:01,440 --> 00:47:04,560
um but for enums enums use the colon

1163
00:47:04,560 --> 00:47:06,960
colon

1164
00:47:09,200 --> 00:47:12,160
right so we've set this in we've picked

1165
00:47:12,160 --> 00:47:14,400
one of the enum values so this one we've

1166
00:47:14,400 --> 00:47:14,800
picked

1167
00:47:14,800 --> 00:47:18,240
false and then

1168
00:47:18,240 --> 00:47:20,880
once we've made this value you see that

1169
00:47:20,880 --> 00:47:21,680
its type

1170
00:47:21,680 --> 00:47:25,359
is this is tree them so at this point

1171
00:47:25,359 --> 00:47:28,960
we don't know which one it is is it

1172
00:47:28,960 --> 00:47:32,400
false or is it true we no longer know

1173
00:47:32,400 --> 00:47:35,359
after this point in terms of the type

1174
00:47:35,359 --> 00:47:37,040
system

1175
00:47:37,040 --> 00:47:41,040
and so what we need to do is to match

1176
00:47:41,040 --> 00:47:44,960
and match is going to look at this value

1177
00:47:44,960 --> 00:47:48,000
and kind of unpack it for us so that we

1178
00:47:48,000 --> 00:47:50,480
can do

1179
00:47:50,839 --> 00:47:53,920
one for each case for each case and that

1180
00:47:53,920 --> 00:47:55,200
enumeration

1181
00:47:55,200 --> 00:47:57,839
we can do something and uh something

1182
00:47:57,839 --> 00:48:00,720
different with the value

1183
00:48:01,280 --> 00:48:04,480
so it says uh this is mitching missing

1184
00:48:04,480 --> 00:48:05,280
match arm

1185
00:48:05,280 --> 00:48:08,319
that's just a way of saying this match

1186
00:48:08,319 --> 00:48:11,359
needs to actually satisfy or or

1187
00:48:11,359 --> 00:48:15,599
check for every case in that enumeration

1188
00:48:15,599 --> 00:48:18,319
so let's start to check for each of

1189
00:48:18,319 --> 00:48:19,599
these cases

1190
00:48:19,599 --> 00:48:22,880
we can say is true so for the true case

1191
00:48:22,880 --> 00:48:27,280
we can say print line true

1192
00:48:28,079 --> 00:48:31,119
and then is true false

1193
00:48:31,119 --> 00:48:35,839
print line false

1194
00:48:40,319 --> 00:48:43,200
and then we'll run this

1195
00:48:45,520 --> 00:48:49,839
so this gives us a way of doing

1196
00:48:50,240 --> 00:48:52,640
i mean a lot of different ways of

1197
00:48:52,640 --> 00:48:53,359
working

1198
00:48:53,359 --> 00:48:56,480
with languages namely like a more of a

1199
00:48:56,480 --> 00:48:57,440
state machine

1200
00:48:57,440 --> 00:49:00,800
or more of a when you're in a situation

1201
00:49:00,800 --> 00:49:03,760
where it could be one of a set of states

1202
00:49:03,760 --> 00:49:06,640
then an enumeration is a very common way

1203
00:49:06,640 --> 00:49:10,079
to represent that in rust

1204
00:49:10,160 --> 00:49:12,880
so being able to get a value and then

1205
00:49:12,880 --> 00:49:14,319
pass that value in

1206
00:49:14,319 --> 00:49:16,960
not knowing what the state of it is but

1207
00:49:16,960 --> 00:49:17,520
then

1208
00:49:17,520 --> 00:49:19,520
being able to use the match statement to

1209
00:49:19,520 --> 00:49:20,800
query

1210
00:49:20,800 --> 00:49:23,520
what the values actual you know state is

1211
00:49:23,520 --> 00:49:25,200
underneath the surface

1212
00:49:25,200 --> 00:49:28,319
and then executing some code based on

1213
00:49:28,319 --> 00:49:31,599
what the different possibilities are

1214
00:49:31,599 --> 00:49:33,599
one of the nice things about

1215
00:49:33,599 --> 00:49:34,880
enumerations and rus

1216
00:49:34,880 --> 00:49:36,640
is that they can carry along some

1217
00:49:36,640 --> 00:49:38,079
information

1218
00:49:38,079 --> 00:49:41,280
so for example this true

1219
00:49:41,280 --> 00:49:45,119
could carry along with it uh an i64

1220
00:49:45,119 --> 00:49:47,040
like we were doing earlier so let's say

1221
00:49:47,040 --> 00:49:48,559
maybe this is like

1222
00:49:48,559 --> 00:49:50,480
if there's an ide that goes along with

1223
00:49:50,480 --> 00:49:53,040
it it will say yes there is one

1224
00:49:53,040 --> 00:49:56,160
and it will give you this this number

1225
00:49:56,160 --> 00:49:57,520
and if there isn't it just says okay

1226
00:49:57,520 --> 00:50:00,079
that's false so we've changed this to

1227
00:50:00,079 --> 00:50:01,200
say

1228
00:50:01,200 --> 00:50:05,280
that um it has kind of a if you will

1229
00:50:05,280 --> 00:50:06,400
kind of a payload

1230
00:50:06,400 --> 00:50:09,839
like that might be a

1231
00:50:09,839 --> 00:50:11,119
silly way of saying it but you can kind

1232
00:50:11,119 --> 00:50:12,960
of see what i'm saying like this this

1233
00:50:12,960 --> 00:50:13,839
extra data

1234
00:50:13,839 --> 00:50:15,680
is writing along with the fact that it's

1235
00:50:15,680 --> 00:50:17,839
true so once we match with true

1236
00:50:17,839 --> 00:50:20,000
we can get this data out and you'll

1237
00:50:20,000 --> 00:50:22,079
notice here that we're erroring

1238
00:50:22,079 --> 00:50:24,559
and the error is saying yeah okay cool

1239
00:50:24,559 --> 00:50:27,119
it's true but in order for you to

1240
00:50:27,119 --> 00:50:28,880
actually pattern match this you have to

1241
00:50:28,880 --> 00:50:29,520
not only

1242
00:50:29,520 --> 00:50:32,160
match that is true but you have to do

1243
00:50:32,160 --> 00:50:34,800
something with the data

1244
00:50:34,800 --> 00:50:37,040
we can ignore it using underscore that's

1245
00:50:37,040 --> 00:50:38,960
totally one way we can do that

1246
00:50:38,960 --> 00:50:42,240
or we can use a variable and once we use

1247
00:50:42,240 --> 00:50:44,079
a variable

1248
00:50:44,079 --> 00:50:46,559
it will take that value bind it to that

1249
00:50:46,559 --> 00:50:47,200
variable

1250
00:50:47,200 --> 00:50:51,280
so now x is equal to what was contained

1251
00:50:51,280 --> 00:50:51,760
in

1252
00:50:51,760 --> 00:50:55,599
that payload and then we can just print

1253
00:50:55,599 --> 00:50:57,920
that out

1254
00:50:57,920 --> 00:51:01,040
if i can write my curlys

1255
00:51:01,680 --> 00:51:03,760
all right it's still warning us that

1256
00:51:03,760 --> 00:51:05,440
true isn't being used let's actually use

1257
00:51:05,440 --> 00:51:05,920
it

1258
00:51:05,920 --> 00:51:09,680
so we can see this payload come out

1259
00:51:09,680 --> 00:51:13,599
if we run this we'll say true100

1260
00:51:13,599 --> 00:51:15,119
so this is actually quite a bit

1261
00:51:15,119 --> 00:51:16,800
different than

1262
00:51:16,800 --> 00:51:19,839
languages that have like typescript or

1263
00:51:19,839 --> 00:51:20,400
whatever

1264
00:51:20,400 --> 00:51:24,000
that have enumerations where

1265
00:51:24,000 --> 00:51:26,800
it's only the true or false it's not any

1266
00:51:26,800 --> 00:51:28,000
of the payload

1267
00:51:28,000 --> 00:51:31,200
and the payload actually is

1268
00:51:31,200 --> 00:51:34,000
excuse me is one of the more important

1269
00:51:34,000 --> 00:51:36,079
parts about

1270
00:51:36,079 --> 00:51:39,280
about um pattern matching and

1271
00:51:39,280 --> 00:51:42,240
languages like rust because not only do

1272
00:51:42,240 --> 00:51:43,599
you get the state

1273
00:51:43,599 --> 00:51:47,040
like the kind of the the the name of the

1274
00:51:47,040 --> 00:51:49,040
state you also get the data that goes

1275
00:51:49,040 --> 00:51:50,480
along with the state

1276
00:51:50,480 --> 00:51:54,000
so if you want to use this again for

1277
00:51:54,000 --> 00:51:56,960
state machines or something then you can

1278
00:51:56,960 --> 00:51:58,319
have information in there

1279
00:51:58,319 --> 00:52:01,040
that will actually make this far more

1280
00:52:01,040 --> 00:52:01,839
powerful

1281
00:52:01,839 --> 00:52:05,520
than just knowing what state you're in

1282
00:52:05,520 --> 00:52:07,839
and rust actually let me pause for a

1283
00:52:07,839 --> 00:52:10,319
second any questions about anything i've

1284
00:52:10,319 --> 00:52:11,920
i've talked about up to this point we

1285
00:52:11,920 --> 00:52:13,520
kind of talked about structs and enums

1286
00:52:13,520 --> 00:52:16,839
maybe any questions about structs and

1287
00:52:16,839 --> 00:52:19,839
enums

1288
00:52:29,920 --> 00:52:31,119
are there other pattern matching

1289
00:52:31,119 --> 00:52:33,599
languages than rust yeah so russ comes

1290
00:52:33,599 --> 00:52:34,720
from a heritage

1291
00:52:34,720 --> 00:52:37,760
of functional programming languages if

1292
00:52:37,760 --> 00:52:38,960
you've

1293
00:52:38,960 --> 00:52:41,839
ever had a chance to check out haskell

1294
00:52:41,839 --> 00:52:43,760
or ocamel

1295
00:52:43,760 --> 00:52:46,079
these languages have generally more

1296
00:52:46,079 --> 00:52:48,160
sophisticated pattern matching

1297
00:52:48,160 --> 00:52:51,359
because it's such it's like a

1298
00:52:51,359 --> 00:52:54,720
how you work with data is so integrated

1299
00:52:54,720 --> 00:52:55,520
with this

1300
00:52:55,520 --> 00:52:58,240
idea of of being able to have not only a

1301
00:52:58,240 --> 00:52:59,200
state

1302
00:52:59,200 --> 00:53:02,400
but data along with that state so yeah

1303
00:53:02,400 --> 00:53:03,920
other functional languages do tend to

1304
00:53:03,920 --> 00:53:08,160
have more sophisticated pattern matching

1305
00:53:08,160 --> 00:53:13,760
yep cool i'll just keep plugging away

1306
00:53:13,760 --> 00:53:18,000
so that's enums so rust uses this

1307
00:53:18,000 --> 00:53:22,640
uh enums be like in a way that

1308
00:53:22,640 --> 00:53:26,079
give it the ability to do error checking

1309
00:53:26,079 --> 00:53:29,920
an error reporting without any

1310
00:53:29,920 --> 00:53:30,640
exceptions

1311
00:53:30,640 --> 00:53:33,280
so there's no exceptions like if you

1312
00:53:33,280 --> 00:53:33,839
come from

1313
00:53:33,839 --> 00:53:36,800
say javascript or c sharp languages like

1314
00:53:36,800 --> 00:53:37,920
that

1315
00:53:37,920 --> 00:53:39,680
you're used to being able to throw an

1316
00:53:39,680 --> 00:53:41,760
exception and then to catch an

1317
00:53:41,760 --> 00:53:44,079
exception and do something in those

1318
00:53:44,079 --> 00:53:46,000
cases that's that's the kind of common

1319
00:53:46,000 --> 00:53:47,359
way that you write code in those

1320
00:53:47,359 --> 00:53:49,599
languages

1321
00:53:49,599 --> 00:53:52,720
in rust rust is

1322
00:53:52,720 --> 00:53:54,559
a much more what's called like

1323
00:53:54,559 --> 00:53:56,319
value-based languages

1324
00:53:56,319 --> 00:53:59,920
instead of thinking about exceptions and

1325
00:53:59,920 --> 00:54:03,200
non-local kind of like returning to some

1326
00:54:03,200 --> 00:54:03,680
other

1327
00:54:03,680 --> 00:54:05,760
spot rather than the return location for

1328
00:54:05,760 --> 00:54:07,359
your function

1329
00:54:07,359 --> 00:54:09,520
russ just returns from the function

1330
00:54:09,520 --> 00:54:10,880
that's all it does

1331
00:54:10,880 --> 00:54:13,760
but when it returns it returns in such a

1332
00:54:13,760 --> 00:54:14,480
way that

1333
00:54:14,480 --> 00:54:16,720
you know if that function is succeeded

1334
00:54:16,720 --> 00:54:17,760
or not

1335
00:54:17,760 --> 00:54:20,720
and you can work with the value let's

1336
00:54:20,720 --> 00:54:22,319
actually kind of

1337
00:54:22,319 --> 00:54:24,960
unpack what i just said through an

1338
00:54:24,960 --> 00:54:27,440
example

1339
00:54:28,000 --> 00:54:32,240
let's get rid of our structs and enums

1340
00:54:32,240 --> 00:54:35,599
and get us back to

1341
00:54:36,160 --> 00:54:37,520
writing a function so we're going to

1342
00:54:37,520 --> 00:54:39,760
write a function and this function is

1343
00:54:39,760 --> 00:54:41,280
going to be

1344
00:54:41,280 --> 00:54:44,400
um something like it's going to do some

1345
00:54:44,400 --> 00:54:45,280
work

1346
00:54:45,280 --> 00:54:47,359
and it's going to return a result that

1347
00:54:47,359 --> 00:54:50,079
result will either be a string

1348
00:54:50,079 --> 00:54:53,680
or it will be um

1349
00:54:53,680 --> 00:54:55,920
what kind of errors do we want to use i

1350
00:54:55,920 --> 00:54:58,079
haven't used used before

1351
00:54:58,079 --> 00:55:00,720
uh in this in this stream so maybe let's

1352
00:55:00,720 --> 00:55:01,359
use

1353
00:55:01,359 --> 00:55:06,480
standard error error

1354
00:55:06,480 --> 00:55:10,000
and then we'll use error here

1355
00:55:12,240 --> 00:55:15,520
all right so i've i've made a new return

1356
00:55:15,520 --> 00:55:17,440
type for this function

1357
00:55:17,440 --> 00:55:20,480
and this is result i haven't really

1358
00:55:20,480 --> 00:55:22,160
showed generics before but if you've

1359
00:55:22,160 --> 00:55:23,760
programmed in languages that have

1360
00:55:23,760 --> 00:55:24,960
generics

1361
00:55:24,960 --> 00:55:28,079
these angular angle brackets are

1362
00:55:28,079 --> 00:55:32,240
saying like um here is i've got a type

1363
00:55:32,240 --> 00:55:36,799
and it that type has two type parameters

1364
00:55:36,799 --> 00:55:38,400
actually let me just quickly before i

1365
00:55:38,400 --> 00:55:40,000
jump to this part because i think

1366
00:55:40,000 --> 00:55:41,839
it's important to do the kind of step

1367
00:55:41,839 --> 00:55:44,000
right before this

1368
00:55:44,000 --> 00:55:48,160
so let's do our enum again

1369
00:55:48,160 --> 00:55:50,319
and we'll say this enum it either

1370
00:55:50,319 --> 00:55:52,240
succeeds with a value

1371
00:55:52,240 --> 00:55:55,760
or it fails okay

1372
00:55:55,760 --> 00:55:58,480
so this enum in fact we're going to

1373
00:55:58,480 --> 00:56:01,040
write the result enum here

1374
00:56:01,040 --> 00:56:02,799
so we need something that says if it

1375
00:56:02,799 --> 00:56:04,720
succeeds

1376
00:56:04,720 --> 00:56:07,280
uh so when it's okay and when the value

1377
00:56:07,280 --> 00:56:08,160
is okay

1378
00:56:08,160 --> 00:56:10,880
there is something here and then when it

1379
00:56:10,880 --> 00:56:12,240
fails

1380
00:56:12,240 --> 00:56:14,319
we'll use error and okay because we'll

1381
00:56:14,319 --> 00:56:16,319
see those in a second

1382
00:56:16,319 --> 00:56:18,799
so when it succeeds it gets this one

1383
00:56:18,799 --> 00:56:19,760
when it fails

1384
00:56:19,760 --> 00:56:21,680
it returns this one and we don't know

1385
00:56:21,680 --> 00:56:23,200
which one it is again we'll have to

1386
00:56:23,200 --> 00:56:24,799
pattern match on it to know

1387
00:56:24,799 --> 00:56:26,960
which one and which one succeeds and

1388
00:56:26,960 --> 00:56:28,640
which one fails

1389
00:56:28,640 --> 00:56:30,640
but at the very least we know we've got

1390
00:56:30,640 --> 00:56:32,640
one where it succeeds and one where it

1391
00:56:32,640 --> 00:56:34,960
fails

1392
00:56:35,440 --> 00:56:38,000
to actually put something in as the

1393
00:56:38,000 --> 00:56:40,240
payload

1394
00:56:40,240 --> 00:56:43,200
we need to know the type and if we want

1395
00:56:43,200 --> 00:56:44,240
this to work over

1396
00:56:44,240 --> 00:56:46,880
anything that succeeds and anything that

1397
00:56:46,880 --> 00:56:48,400
fails

1398
00:56:48,400 --> 00:56:50,160
now we need to use a generic so this

1399
00:56:50,160 --> 00:56:53,280
will be actually defining a generic

1400
00:56:53,280 --> 00:56:56,240
so we're going to define kind of a will

1401
00:56:56,240 --> 00:56:58,160
if you will a success case

1402
00:56:58,160 --> 00:57:01,040
and a failure case and this is going to

1403
00:57:01,040 --> 00:57:03,119
be the type

1404
00:57:03,119 --> 00:57:05,599
that when it succeeds it will give you a

1405
00:57:05,599 --> 00:57:07,119
success type

1406
00:57:07,119 --> 00:57:10,400
so we'll say success

1407
00:57:10,400 --> 00:57:12,880
and when it fails we'll give you a

1408
00:57:12,880 --> 00:57:15,280
failure type

1409
00:57:15,280 --> 00:57:18,480
all right so these two parameters

1410
00:57:18,480 --> 00:57:20,400
we have to parametrize it because we

1411
00:57:20,400 --> 00:57:22,880
don't know

1412
00:57:22,880 --> 00:57:26,640
what what concrete types what

1413
00:57:26,640 --> 00:57:29,839
what types this will be used

1414
00:57:29,839 --> 00:57:33,280
with yet we we're just saying they're

1415
00:57:33,280 --> 00:57:35,200
generic over these types

1416
00:57:35,200 --> 00:57:36,880
and then when you actually create a

1417
00:57:36,880 --> 00:57:39,040
result type later

1418
00:57:39,040 --> 00:57:41,680
you'll tell me what they are so for

1419
00:57:41,680 --> 00:57:43,839
example i could say

1420
00:57:43,839 --> 00:57:46,960
let result say

1421
00:57:46,960 --> 00:57:50,000
this one is one where it returns i-64 if

1422
00:57:50,000 --> 00:57:51,200
it succeeds

1423
00:57:51,200 --> 00:57:55,599
or error if it fails

1424
00:57:55,599 --> 00:57:59,119
um it may not let me use the term result

1425
00:57:59,119 --> 00:58:00,079
here

1426
00:58:00,079 --> 00:58:02,559
let me see yeah i might get in trouble

1427
00:58:02,559 --> 00:58:04,559
for that

1428
00:58:04,559 --> 00:58:08,240
um because result is actually a built-in

1429
00:58:08,240 --> 00:58:09,760
let's call it something else like my

1430
00:58:09,760 --> 00:58:12,160
result

1431
00:58:12,400 --> 00:58:15,599
and my result and there may be another

1432
00:58:15,599 --> 00:58:16,880
step but

1433
00:58:16,880 --> 00:58:19,839
uh basically yeah let me just check this

1434
00:58:19,839 --> 00:58:21,599
real quick

1435
00:58:21,599 --> 00:58:23,440
yeah it's complaining it needs to know a

1436
00:58:23,440 --> 00:58:25,040
little bit more i really don't want to

1437
00:58:25,040 --> 00:58:26,799
go into the details

1438
00:58:26,799 --> 00:58:28,880
for this particular example because it

1439
00:58:28,880 --> 00:58:30,319
does need a little bit more

1440
00:58:30,319 --> 00:58:31,760
but they're a little they're like a few

1441
00:58:31,760 --> 00:58:34,160
steps later than we are right now

1442
00:58:34,160 --> 00:58:36,640
um but just to kind of squint at it a

1443
00:58:36,640 --> 00:58:37,520
bit

1444
00:58:37,520 --> 00:58:40,960
you can see that we need a true uh type

1445
00:58:40,960 --> 00:58:44,720
and like a failure type

1446
00:58:44,720 --> 00:58:47,760
all right with that in mind and again

1447
00:58:47,760 --> 00:58:50,160
we can circle back to this later maybe

1448
00:58:50,160 --> 00:58:52,160
in an upcoming stream or something

1449
00:58:52,160 --> 00:58:53,680
we'll actually unpack why this is

1450
00:58:53,680 --> 00:58:55,520
failing now but for now

1451
00:58:55,520 --> 00:58:58,559
don't worry about it we'll use the

1452
00:58:58,559 --> 00:59:00,640
actual built-in result which is actually

1453
00:59:00,640 --> 00:59:01,040
this

1454
00:59:01,040 --> 00:59:04,480
but implemented with all the the

1455
00:59:04,480 --> 00:59:06,079
the next steps that it would need to

1456
00:59:06,079 --> 00:59:08,559
succeed

1457
00:59:10,240 --> 00:59:12,559
so we'll say what we're saying process

1458
00:59:12,559 --> 00:59:14,079
and that's going to return a result

1459
00:59:14,079 --> 00:59:17,200
that is either string or error so here

1460
00:59:17,200 --> 00:59:18,160
is same idea

1461
00:59:18,160 --> 00:59:21,760
that we had before this is an enum

1462
00:59:21,760 --> 00:59:24,799
and the enum has a a success case

1463
00:59:24,799 --> 00:59:27,760
and a failure case if it succeeds it

1464
00:59:27,760 --> 00:59:28,720
returns a string

1465
00:59:28,720 --> 00:59:32,960
if it fails it returns an error

1466
00:59:32,960 --> 00:59:37,200
in our process function just for now

1467
00:59:37,200 --> 00:59:40,480
we'll use the string.from like was

1468
00:59:40,480 --> 00:59:42,000
suggested

1469
00:59:42,000 --> 00:59:45,440
we'll just say yay all right so this is

1470
00:59:45,440 --> 00:59:46,720
a

1471
00:59:46,720 --> 00:59:50,799
result all right did i miss a step

1472
00:59:50,799 --> 00:59:52,880
result is a type that represents blah

1473
00:59:52,880 --> 00:59:55,359
blah blah the size of the type

1474
00:59:55,359 --> 00:59:59,280
oh right see i i should have just

1475
00:59:59,280 --> 01:00:02,319
just let me let it tell me what to do

1476
01:00:02,319 --> 01:00:06,880
done sized oh i need to say that this is

1477
01:00:06,880 --> 01:00:10,000
sorry it's a little extra information

1478
01:00:10,000 --> 01:00:12,319
and then i have to say done in here

1479
01:00:12,319 --> 01:00:13,040
sheesh

1480
01:00:13,040 --> 01:00:16,160
okay there's a lot of

1481
01:00:16,160 --> 01:00:17,920
other stuff going on in the background i

1482
01:00:17,920 --> 01:00:19,760
could have picked a like a more concrete

1483
01:00:19,760 --> 01:00:20,640
error

1484
01:00:20,640 --> 01:00:22,640
here i tried to pick like the most

1485
01:00:22,640 --> 01:00:23,839
general error

1486
01:00:23,839 --> 01:00:25,520
and to use the most general thing you

1487
01:00:25,520 --> 01:00:28,079
have to do in a couple extra steps but

1488
01:00:28,079 --> 01:00:32,559
fine fair enough same idea applies

1489
01:00:32,559 --> 01:00:34,480
there's a success type and now a

1490
01:00:34,480 --> 01:00:37,200
slightly more complicated but

1491
01:00:37,200 --> 01:00:39,200
basically just saying the same thing an

1492
01:00:39,200 --> 01:00:40,880
error and this is

1493
01:00:40,880 --> 01:00:44,559
this is like a very generic

1494
01:00:44,559 --> 01:00:48,319
error it's saying anything that

1495
01:00:48,319 --> 01:00:50,319
satisfies a trait and we'll talk about

1496
01:00:50,319 --> 01:00:51,599
traits here in a minute

1497
01:00:51,599 --> 01:00:54,400
any time that this thing gets satisfied

1498
01:00:54,400 --> 01:00:57,839
that can be returned in this position

1499
01:00:58,079 --> 01:00:59,760
thanks russ thanks for keeping me nice

1500
01:00:59,760 --> 01:01:02,319
and generic

1501
01:01:02,319 --> 01:01:05,440
okay so now

1502
01:01:05,440 --> 01:01:09,680
let's call this thing so if i say

1503
01:01:09,680 --> 01:01:13,599
let result equal process

1504
01:01:13,599 --> 01:01:16,799
you'll notice that the type and this

1505
01:01:16,799 --> 01:01:19,760
this colon this type annotation is not

1506
01:01:19,760 --> 01:01:20,880
actually in the code

1507
01:01:20,880 --> 01:01:24,000
this is just vs code and rust analyzer

1508
01:01:24,000 --> 01:01:26,319
giving me a hint as to what the type is

1509
01:01:26,319 --> 01:01:28,640
in this location

1510
01:01:28,640 --> 01:01:32,319
so it's saying result is a result a

1511
01:01:32,319 --> 01:01:35,599
capital capital r result type

1512
01:01:35,599 --> 01:01:40,400
and it is string or error

1513
01:01:42,960 --> 01:01:46,160
so let's say i wanted to print this out

1514
01:01:46,160 --> 01:01:50,240
right my result

1515
01:01:50,799 --> 01:01:55,039
is result and it's going to complain

1516
01:01:55,039 --> 01:01:56,960
and one of the reasons that it complains

1517
01:01:56,960 --> 01:01:58,480
is that

1518
01:01:58,480 --> 01:02:01,839
gobbly that we saw before

1519
01:02:01,839 --> 01:02:04,559
the same thing i don't know how to print

1520
01:02:04,559 --> 01:02:05,680
an enum

1521
01:02:05,680 --> 01:02:08,640
and really if i was to try to use this

1522
01:02:08,640 --> 01:02:10,400
as a string

1523
01:02:10,400 --> 01:02:14,000
so let's say i try to use this as

1524
01:02:14,000 --> 01:02:15,440
well in this case i'm kind of trying to

1525
01:02:15,440 --> 01:02:17,039
use it as a string

1526
01:02:17,039 --> 01:02:19,359
like if this succeeded i would have a

1527
01:02:19,359 --> 01:02:21,359
string and this would be valid

1528
01:02:21,359 --> 01:02:24,559
how do i get from here where i've got

1529
01:02:24,559 --> 01:02:27,599
an error to actually you know

1530
01:02:27,599 --> 01:02:32,640
working with this this result type

1531
01:02:32,640 --> 01:02:34,880
or working with the string inside of the

1532
01:02:34,880 --> 01:02:35,680
result

1533
01:02:35,680 --> 01:02:38,640
if it's there and that's where we have

1534
01:02:38,640 --> 01:02:41,280
this pattern matching like we did before

1535
01:02:41,280 --> 01:02:43,680
so we have like the okay case we'll get

1536
01:02:43,680 --> 01:02:45,520
our value out

1537
01:02:45,520 --> 01:02:47,680
now you'll see that once we've matched

1538
01:02:47,680 --> 01:02:49,200
with ok

1539
01:02:49,200 --> 01:02:51,920
right we know it's either okay or air e

1540
01:02:51,920 --> 01:02:53,200
r r

1541
01:02:53,200 --> 01:02:55,839
so in the okay case we know it's a

1542
01:02:55,839 --> 01:02:56,400
string

1543
01:02:56,400 --> 01:03:00,960
and now we can just happily print our

1544
01:03:00,960 --> 01:03:04,559
our line here with uh x

1545
01:03:04,559 --> 01:03:06,880
and the error case we know in this case

1546
01:03:06,880 --> 01:03:08,000
this is an error

1547
01:03:08,000 --> 01:03:12,000
and you can see that the this box dying

1548
01:03:12,000 --> 01:03:13,359
error this uh

1549
01:03:13,359 --> 01:03:14,799
thing i was like well i don't know if i

1550
01:03:14,799 --> 01:03:16,799
want to get into this quite yet

1551
01:03:16,799 --> 01:03:19,680
let's just quickly talk about this box

1552
01:03:19,680 --> 01:03:21,119
means that it's on the heap

1553
01:03:21,119 --> 01:03:23,920
somewhere i've stored it out on the heap

1554
01:03:23,920 --> 01:03:24,400
dying

1555
01:03:24,400 --> 01:03:26,960
error means something that implements

1556
01:03:26,960 --> 01:03:28,960
the error trait and i don't know what it

1557
01:03:28,960 --> 01:03:29,680
is

1558
01:03:29,680 --> 01:03:32,799
so something on the heap that is that

1559
01:03:32,799 --> 01:03:34,480
implements the error trait i don't know

1560
01:03:34,480 --> 01:03:35,280
what it is

1561
01:03:35,280 --> 01:03:36,799
i just know it's on the heap but i know

1562
01:03:36,799 --> 01:03:38,319
it implements the error trait that's all

1563
01:03:38,319 --> 01:03:40,799
it's saying

1564
01:03:41,520 --> 01:03:44,640
all right so this error instead of

1565
01:03:44,640 --> 01:03:46,319
printing out the air we'll just say

1566
01:03:46,319 --> 01:03:48,960
it errored

1567
01:03:49,760 --> 01:03:51,839
and call that done oh notice it's

1568
01:03:51,839 --> 01:03:53,839
complaining i don't have the

1569
01:03:53,839 --> 01:03:56,880
fat error here and now it's

1570
01:03:56,880 --> 01:03:58,319
warning me i'm not using it i'm not

1571
01:03:58,319 --> 01:04:01,680
gonna i'm just gonna ignore that

1572
01:04:02,640 --> 01:04:06,400
cool so now i have called

1573
01:04:06,400 --> 01:04:09,119
a function and got a result out and this

1574
01:04:09,119 --> 01:04:09,760
pattern

1575
01:04:09,760 --> 01:04:11,760
of calling functions that return a

1576
01:04:11,760 --> 01:04:13,760
result you'll see it

1577
01:04:13,760 --> 01:04:17,839
all the time in russ code because

1578
01:04:17,839 --> 01:04:20,319
we don't have exceptions in rust what we

1579
01:04:20,319 --> 01:04:22,400
use is this capital r result

1580
01:04:22,400 --> 01:04:26,240
to just return values and the values

1581
01:04:26,240 --> 01:04:28,480
uh are in that left-hand side of the

1582
01:04:28,480 --> 01:04:29,440
result so

1583
01:04:29,440 --> 01:04:31,200
whatever we see on the left-hand side of

1584
01:04:31,200 --> 01:04:32,640
the comma that's

1585
01:04:32,640 --> 01:04:35,839
that's the success case and so

1586
01:04:35,839 --> 01:04:38,000
really when you start to read this over

1587
01:04:38,000 --> 01:04:39,680
time you kind of

1588
01:04:39,680 --> 01:04:41,599
read the name and then you say oh it's a

1589
01:04:41,599 --> 01:04:44,480
result okay this success is string

1590
01:04:44,480 --> 01:04:46,640
error almost always is something like

1591
01:04:46,640 --> 01:04:49,359
this box stein error or something like

1592
01:04:49,359 --> 01:04:52,079
some error type that's specific to the

1593
01:04:52,079 --> 01:04:53,200
crate or to

1594
01:04:53,200 --> 01:04:56,160
doing i o and you can always think of

1595
01:04:56,160 --> 01:04:58,000
that as like your error

1596
01:04:58,000 --> 01:05:00,400
case in a separate separate part of your

1597
01:05:00,400 --> 01:05:01,039
brain

1598
01:05:01,039 --> 01:05:03,280
if you will but most of the time you're

1599
01:05:03,280 --> 01:05:04,319
just you just want to know what

1600
01:05:04,319 --> 01:05:06,960
success is

1601
01:05:07,680 --> 01:05:10,720
this match statement is

1602
01:05:10,720 --> 01:05:12,559
pretty big if i had to write this all

1603
01:05:12,559 --> 01:05:14,559
the time

1604
01:05:14,559 --> 01:05:16,400
i'd probably be pretty sad to write russ

1605
01:05:16,400 --> 01:05:17,839
code

1606
01:05:17,839 --> 01:05:21,359
because this kind of error checking

1607
01:05:21,359 --> 01:05:23,280
and dealing with errors that come back

1608
01:05:23,280 --> 01:05:24,799
from functions

1609
01:05:24,799 --> 01:05:27,599
happens all the time in rust there needs

1610
01:05:27,599 --> 01:05:28,720
to be a shorthand

1611
01:05:28,720 --> 01:05:36,000
and luckily there is

1612
01:05:36,000 --> 01:05:39,039
how's that for cliffhanger

1613
01:05:39,039 --> 01:05:42,079
okay so

1614
01:05:42,079 --> 01:05:46,559
we have this result and

1615
01:05:46,559 --> 01:05:48,799
let's actually use another feature of

1616
01:05:48,799 --> 01:05:50,559
rust to get

1617
01:05:50,559 --> 01:05:56,400
at the result right the the success case

1618
01:05:56,559 --> 01:05:58,000
to do that i'm going to have to change

1619
01:05:58,000 --> 01:06:00,160
my main just a little bit

1620
01:06:00,160 --> 01:06:03,119
i'll also give the main result case and

1621
01:06:03,119 --> 01:06:04,799
i'll also say box

1622
01:06:04,799 --> 01:06:08,799
time er

1623
01:06:08,799 --> 01:06:12,720
as a result now it's complaining okay

1624
01:06:12,720 --> 01:06:16,720
main needs to return some value cool

1625
01:06:16,839 --> 01:06:18,559
cool so now

1626
01:06:18,559 --> 01:06:21,440
whenever you have a result returned from

1627
01:06:21,440 --> 01:06:23,920
a function

1628
01:06:24,000 --> 01:06:27,440
you do have to return a result like

1629
01:06:27,440 --> 01:06:29,200
it is your responsibility to always

1630
01:06:29,200 --> 01:06:31,280
return something

1631
01:06:31,280 --> 01:06:34,319
in the success case

1632
01:06:34,400 --> 01:06:37,920
and because this result match this match

1633
01:06:37,920 --> 01:06:39,359
part of the function didn't really

1634
01:06:39,359 --> 01:06:41,760
return anything i just printed out some

1635
01:06:41,760 --> 01:06:45,039
values russ will say

1636
01:06:45,039 --> 01:06:47,760
you said it returned a result so every

1637
01:06:47,760 --> 01:06:48,799
path through that per

1638
01:06:48,799 --> 01:06:50,160
every path through that function has to

1639
01:06:50,160 --> 01:06:52,559
return a result so we do have to return

1640
01:06:52,559 --> 01:06:55,359
a result here

1641
01:06:55,920 --> 01:06:57,680
all right now that we turn a result here

1642
01:06:57,680 --> 01:07:00,000
you notice the compile errors have gone

1643
01:07:00,000 --> 01:07:01,359
away but we still have this

1644
01:07:01,359 --> 01:07:04,000
gigantic block of a match statement in

1645
01:07:04,000 --> 01:07:06,160
the middle of the function

1646
01:07:06,160 --> 01:07:07,920
so let's actually turn this into

1647
01:07:07,920 --> 01:07:10,319
something

1648
01:07:10,400 --> 01:07:12,880
to get the result and then to use the

1649
01:07:12,880 --> 01:07:14,160
result

1650
01:07:14,160 --> 01:07:16,960
we just need to use the question mark so

1651
01:07:16,960 --> 01:07:19,280
once we use the question mark

1652
01:07:19,280 --> 01:07:20,960
let me just show you what it looks like

1653
01:07:20,960 --> 01:07:24,640
real quick my result

1654
01:07:25,039 --> 01:07:27,039
and we can get this do the same print we

1655
01:07:27,039 --> 01:07:28,480
did before

1656
01:07:28,480 --> 01:07:31,200
um for the res the success case by doing

1657
01:07:31,200 --> 01:07:32,240
it this way

1658
01:07:32,240 --> 01:07:35,440
result question mark

1659
01:07:37,839 --> 01:07:42,240
all right let's run that

1660
01:07:42,240 --> 01:07:47,280
and all of that match statement

1661
01:07:48,000 --> 01:07:50,559
is almost completely replaced by a

1662
01:07:50,559 --> 01:07:51,359
question mark

1663
01:07:51,359 --> 01:07:54,000
so notice this is a lot smaller and in

1664
01:07:54,000 --> 01:07:55,200
fact

1665
01:07:55,200 --> 01:07:56,960
in practice you wouldn't even write it

1666
01:07:56,960 --> 01:07:58,319
like this

1667
01:07:58,319 --> 01:08:02,319
you would write it something like this

1668
01:08:03,200 --> 01:08:05,920
right even smaller yet so i call the

1669
01:08:05,920 --> 01:08:07,599
function

1670
01:08:07,599 --> 01:08:11,599
and then this question mark says

1671
01:08:11,599 --> 01:08:15,200
if it succeeds give me the value

1672
01:08:15,200 --> 01:08:18,080
if it failed so right so we're in the

1673
01:08:18,080 --> 01:08:19,120
okay

1674
01:08:19,120 --> 01:08:20,719
if it's in the okay case give me the

1675
01:08:20,719 --> 01:08:22,719
value if it's in the

1676
01:08:22,719 --> 01:08:27,439
error case the err case

1677
01:08:27,439 --> 01:08:30,238
then return that immediately out of the

1678
01:08:30,238 --> 01:08:30,719
function

1679
01:08:30,719 --> 01:08:34,319
so it just bubbles it immediately out

1680
01:08:34,640 --> 01:08:36,399
so that's why i had to change the result

1681
01:08:36,399 --> 01:08:38,479
type here because

1682
01:08:38,479 --> 01:08:40,640
if i use question mark it's going to

1683
01:08:40,640 --> 01:08:43,198
return straight out of main

1684
01:08:43,198 --> 01:08:47,039
and give me an error

1685
01:08:47,920 --> 01:08:49,920
generally on your main you may or may

1686
01:08:49,920 --> 01:08:53,198
not use this return type

1687
01:08:53,198 --> 01:08:56,479
you may use other functions that return

1688
01:08:56,479 --> 01:08:58,399
results and they call other functions

1689
01:08:58,399 --> 01:08:59,920
and return results

1690
01:08:59,920 --> 01:09:02,238
and so you have this series of functions

1691
01:09:02,238 --> 01:09:04,880
that call each other that return result

1692
01:09:04,880 --> 01:09:07,279
and then you might have one outside of

1693
01:09:07,279 --> 01:09:08,238
all of them

1694
01:09:08,238 --> 01:09:10,080
that says okay call them they're all

1695
01:09:10,080 --> 01:09:11,600
using question mark

1696
01:09:11,600 --> 01:09:14,158
and then the one that is one that's in

1697
01:09:14,158 --> 01:09:15,679
main or one that's in your kind of

1698
01:09:15,679 --> 01:09:17,759
kernel of functionality

1699
01:09:17,759 --> 01:09:19,198
that's the one that does the actual

1700
01:09:19,198 --> 01:09:21,120
match and then deals with the errors and

1701
01:09:21,120 --> 01:09:21,520
then

1702
01:09:21,520 --> 01:09:24,158
prints them to the screen or whatever

1703
01:09:24,158 --> 01:09:24,960
but it

1704
01:09:24,960 --> 01:09:27,279
cuts down on the amount of boilerplate

1705
01:09:27,279 --> 01:09:28,399
that you have to do

1706
01:09:28,399 --> 01:09:31,600
to work with errors in your system

1707
01:09:31,600 --> 01:09:34,238
is to be able to say for most of the

1708
01:09:34,238 --> 01:09:34,640
time

1709
01:09:34,640 --> 01:09:36,479
all i need to use is question mark and

1710
01:09:36,479 --> 01:09:37,920
i'm just like

1711
01:09:37,920 --> 01:09:40,479
looking into that result statement using

1712
01:09:40,479 --> 01:09:42,158
the value if it's there if it's not i'm

1713
01:09:42,158 --> 01:09:43,600
immediately returning with that error

1714
01:09:43,600 --> 01:09:44,319
message

1715
01:09:44,319 --> 01:09:46,000
and letting the function that called me

1716
01:09:46,000 --> 01:09:48,000
deal with it and then again

1717
01:09:48,000 --> 01:09:51,759
it can kind of bubble up so in practice

1718
01:09:51,759 --> 01:09:55,679
while not exceptions it feels

1719
01:09:55,679 --> 01:10:01,920
as lightweight as exceptions generally

1720
01:10:01,920 --> 01:10:04,159
yep

1721
01:10:05,440 --> 01:10:07,679
if you don't return a result is any

1722
01:10:07,679 --> 01:10:08,960
value implied

1723
01:10:08,960 --> 01:10:12,320
no um in fact i think one of the things

1724
01:10:12,320 --> 01:10:12,800
that

1725
01:10:12,800 --> 01:10:15,120
may change in rust at some point in the

1726
01:10:15,120 --> 01:10:16,080
future

1727
01:10:16,080 --> 01:10:18,640
is that having to always remember to do

1728
01:10:18,640 --> 01:10:19,440
this can be

1729
01:10:19,440 --> 01:10:23,040
a bit cumbersome so um

1730
01:10:23,040 --> 01:10:25,120
oh i see what you're saying yes yes

1731
01:10:25,120 --> 01:10:26,960
andy's right in some cases let me

1732
01:10:26,960 --> 01:10:29,440
let me kind of circle back to that in

1733
01:10:29,440 --> 01:10:32,080
this particular case

1734
01:10:32,080 --> 01:10:35,360
the um you would have to manually say

1735
01:10:35,360 --> 01:10:36,159
okay

1736
01:10:36,159 --> 01:10:39,040
in this particular case andy's point is

1737
01:10:39,040 --> 01:10:40,880
like if i said

1738
01:10:40,880 --> 01:10:43,040
like our greet from before notice i

1739
01:10:43,040 --> 01:10:45,360
didn't return any types here

1740
01:10:45,360 --> 01:10:48,159
this is the same thing as saying this

1741
01:10:48,159 --> 01:10:48,800
like

1742
01:10:48,800 --> 01:10:52,239
the the type that is empty if that makes

1743
01:10:52,239 --> 01:10:54,000
any sense it's uh

1744
01:10:54,000 --> 01:10:56,320
doesn't do anything it doesn't it

1745
01:10:56,320 --> 01:10:58,400
doesn't have any value

1746
01:10:58,400 --> 01:11:01,280
yep you can that that's right that's

1747
01:11:01,280 --> 01:11:02,159
technically correct

1748
01:11:02,159 --> 01:11:05,760
so you can return that value or

1749
01:11:05,760 --> 01:11:08,880
say that the type is that that type and

1750
01:11:08,880 --> 01:11:10,000
it means

1751
01:11:10,000 --> 01:11:13,840
the empty the empty type

1752
01:11:14,320 --> 01:11:17,920
yeah you can do early return manually so

1753
01:11:17,920 --> 01:11:20,239
um i did show that you can do like

1754
01:11:20,239 --> 01:11:21,199
return

1755
01:11:21,199 --> 01:11:23,360
a number here like we could do this

1756
01:11:23,360 --> 01:11:25,120
which would be completely meaningless in

1757
01:11:25,120 --> 01:11:26,400
this example

1758
01:11:26,400 --> 01:11:28,480
but this is an early return and you can

1759
01:11:28,480 --> 01:11:30,560
get the value out that way

1760
01:11:30,560 --> 01:11:34,239
most of the time i would say that

1761
01:11:34,239 --> 01:11:38,080
um well i might i might be making too

1762
01:11:38,080 --> 01:11:39,520
broad as a statement i was about to say

1763
01:11:39,520 --> 01:11:41,280
most of the time you don't see

1764
01:11:41,280 --> 01:11:43,600
early returns that's not true it just

1765
01:11:43,600 --> 01:11:46,239
totally depends on the rest code

1766
01:11:46,239 --> 01:11:48,239
this style of using question marks is

1767
01:11:48,239 --> 01:11:49,520
very common

1768
01:11:49,520 --> 01:11:53,120
so error handling and using

1769
01:11:53,120 --> 01:11:56,480
this implied earlier early return

1770
01:11:56,480 --> 01:12:00,880
via the question mark very common um

1771
01:12:00,880 --> 01:12:03,679
maybe less common is like manual returns

1772
01:12:03,679 --> 01:12:05,679
and early returns

1773
01:12:05,679 --> 01:12:08,159
but maybe more specific to say like it's

1774
01:12:08,159 --> 01:12:09,760
in certain patterns you'll see that

1775
01:12:09,760 --> 01:12:12,400
rather than more general like you would

1776
01:12:12,400 --> 01:12:14,400
in other languages

1777
01:12:14,400 --> 01:12:17,840
yep cool

1778
01:12:17,840 --> 01:12:20,960
all right so that is

1779
01:12:20,960 --> 01:12:23,840
so we talked about structures and

1780
01:12:23,840 --> 01:12:24,719
inhuman

1781
01:12:24,719 --> 01:12:27,920
enums enums and

1782
01:12:27,920 --> 01:12:29,520
a little bit about generics i kind of

1783
01:12:29,520 --> 01:12:31,520
threw that in at the last second

1784
01:12:31,520 --> 01:12:33,840
but again if you're used to languages

1785
01:12:33,840 --> 01:12:35,280
like java or c-sharp

1786
01:12:35,280 --> 01:12:37,760
or typescript or anything like that

1787
01:12:37,760 --> 01:12:40,800
these generics work very similarly

1788
01:12:40,800 --> 01:12:43,120
you just use an angle bracket you pass

1789
01:12:43,120 --> 01:12:43,920
them in

1790
01:12:43,920 --> 01:12:46,560
and it lets you turn a generic type into

1791
01:12:46,560 --> 01:12:50,000
a concrete type

1792
01:12:50,000 --> 01:12:51,840
we've done here for result so we turn

1793
01:12:51,840 --> 01:12:54,080
this into a specific kind of result

1794
01:12:54,080 --> 01:12:56,719
and again here for the result for the

1795
01:12:56,719 --> 01:12:58,239
mean

1796
01:12:58,239 --> 01:13:02,840
um right structs enums errors generics

1797
01:13:02,840 --> 01:13:07,040
cool i think that's a pretty

1798
01:13:07,040 --> 01:13:09,679
i did mention traits oh let's have fun

1799
01:13:09,679 --> 01:13:12,800
with trades what the heck

1800
01:13:13,199 --> 01:13:15,920
what the heck

1801
01:13:17,360 --> 01:13:19,120
let me give my voice one second to calm

1802
01:13:19,120 --> 01:13:22,000
down while i type

1803
01:13:27,360 --> 01:13:28,800
we'll get back to where we were before

1804
01:13:28,800 --> 01:13:33,840
with the employee

1805
01:13:40,400 --> 01:13:43,760
ah yes right so i was about to do what

1806
01:13:43,760 --> 01:13:44,960
we did before

1807
01:13:44,960 --> 01:13:47,280
using the curlies to create an employee

1808
01:13:47,280 --> 01:13:50,080
but i'm going to stop myself

1809
01:13:50,080 --> 01:13:53,440
let me actually write

1810
01:13:53,440 --> 01:13:56,640
more like you would do this

1811
01:13:56,640 --> 01:13:59,679
in a real program in rest and you do

1812
01:13:59,679 --> 01:14:00,000
that

1813
01:14:00,000 --> 01:14:03,040
by typing impul

1814
01:14:03,120 --> 01:14:06,239
and then the name of the type

1815
01:14:06,239 --> 01:14:08,000
generally a struct that you're working

1816
01:14:08,000 --> 01:14:09,679
with but it could be other things like

1817
01:14:09,679 --> 01:14:12,239
an enum

1818
01:14:12,560 --> 01:14:15,920
this is saying not only does this have

1819
01:14:15,920 --> 01:14:18,719
does do we have the struct which is data

1820
01:14:18,719 --> 01:14:20,320
we have

1821
01:14:20,320 --> 01:14:24,640
implementations or methods that go

1822
01:14:24,640 --> 01:14:30,239
and connect to this distract

1823
01:14:31,360 --> 01:14:35,280
so i can create a new here

1824
01:14:35,280 --> 01:14:38,480
and this will return an employee

1825
01:14:38,480 --> 01:14:42,239
and now notice i'm using the

1826
01:14:42,239 --> 01:14:46,800
style that we had before where it was

1827
01:14:46,800 --> 01:14:51,520
an employee and then two parameters

1828
01:14:52,080 --> 01:14:53,840
and keep using the string from now i

1829
01:14:53,840 --> 01:14:56,159
look at it it's not so bad

1830
01:14:56,159 --> 01:14:59,840
um so we'll have a string

1831
01:14:59,840 --> 01:15:02,159
that we we can initialize it with so

1832
01:15:02,159 --> 01:15:03,679
we'll just say default

1833
01:15:03,679 --> 01:15:06,480
and we'll replace this here in a second

1834
01:15:06,480 --> 01:15:10,239
and then 100.

1835
01:15:10,239 --> 01:15:13,920
so this makes a new function that works

1836
01:15:13,920 --> 01:15:15,199
on top of strings

1837
01:15:15,199 --> 01:15:18,560
or on top of this struct and we pass in

1838
01:15:18,560 --> 01:15:20,480
well we haven't passed it in anything

1839
01:15:20,480 --> 01:15:24,000
so this will just create a default

1840
01:15:24,000 --> 01:15:27,120
a default value so we'll say

1841
01:15:27,120 --> 01:15:30,640
new and now we have our employee

1842
01:15:30,640 --> 01:15:32,239
and we could do what we did before we'll

1843
01:15:32,239 --> 01:15:39,360
just make a little print statement

1844
01:15:39,360 --> 01:15:44,400
and something like this

1845
01:15:45,199 --> 01:15:49,760
and this employee will be employee dot

1846
01:15:50,840 --> 01:15:53,120
name

1847
01:15:53,120 --> 01:15:54,960
oh i might have a typo somewhere i'll go

1848
01:15:54,960 --> 01:15:57,679
find it in a second

1849
01:16:01,600 --> 01:16:05,120
all right let's run that

1850
01:16:05,360 --> 01:16:08,480
cool so you can see i can do something

1851
01:16:08,480 --> 01:16:10,000
that feels a little bit more natural

1852
01:16:10,000 --> 01:16:12,800
rather than you know always

1853
01:16:12,800 --> 01:16:15,199
instantiating the full struct

1854
01:16:15,199 --> 01:16:18,159
i can just call new and then have new

1855
01:16:18,159 --> 01:16:20,000
fill it out with whatever it feels

1856
01:16:20,000 --> 01:16:23,600
is appropriate generally

1857
01:16:23,600 --> 01:16:26,000
you'll have a mixture of both of these

1858
01:16:26,000 --> 01:16:28,159
but you may have it so that the new

1859
01:16:28,159 --> 01:16:30,480
also takes in parameters so let's just

1860
01:16:30,480 --> 01:16:33,280
do that real quick

1861
01:16:33,280 --> 01:16:35,280
let's just say it takes in a name call

1862
01:16:35,280 --> 01:16:36,640
that a string

1863
01:16:36,640 --> 01:16:40,960
and then id again i-64

1864
01:16:40,960 --> 01:16:43,840
there's a shorthand to using these so i

1865
01:16:43,840 --> 01:16:44,159
can

1866
01:16:44,159 --> 01:16:47,440
i could say it like this name name id id

1867
01:16:47,440 --> 01:16:50,480
like that so that's

1868
01:16:50,480 --> 01:16:54,080
completely valid perfectly valid

1869
01:16:54,480 --> 01:16:57,600
and then use the

1870
01:17:00,840 --> 01:17:04,239
uh what we're going to call this person

1871
01:17:04,239 --> 01:17:07,840
employee sure whatever it's funny with

1872
01:17:07,840 --> 01:17:09,920
like the things that you pause on

1873
01:17:09,920 --> 01:17:13,360
all right there you go so that is

1874
01:17:13,360 --> 01:17:15,840
not quite right we need to get our

1875
01:17:15,840 --> 01:17:19,120
parentheses in the right place

1876
01:17:19,120 --> 01:17:20,800
and what's up oh yeah it's string that

1877
01:17:20,800 --> 01:17:22,880
from

1878
01:17:22,880 --> 01:17:26,239
okay so

1879
01:17:26,239 --> 01:17:29,679
now our new has two parameters this name

1880
01:17:29,679 --> 01:17:31,199
and the ide

1881
01:17:31,199 --> 01:17:33,520
and then we've called them uh called our

1882
01:17:33,520 --> 01:17:35,360
new with these two parameters

1883
01:17:35,360 --> 01:17:37,280
and then made a new struct and

1884
01:17:37,280 --> 01:17:38,560
initialize it with those

1885
01:17:38,560 --> 01:17:41,520
two parameters so you can run that and

1886
01:17:41,520 --> 01:17:43,280
get what we'd expect

1887
01:17:43,280 --> 01:17:44,480
i was saying earlier that there's

1888
01:17:44,480 --> 01:17:46,400
actually a shorter way of typing this if

1889
01:17:46,400 --> 01:17:48,880
you're just going to use the same

1890
01:17:48,880 --> 01:17:50,719
like the variable and the field are

1891
01:17:50,719 --> 01:17:52,400
going to be the same name

1892
01:17:52,400 --> 01:17:54,960
you can just use it once and it will

1893
01:17:54,960 --> 01:17:56,480
just imply

1894
01:17:56,480 --> 01:17:59,520
create the structure and if you're

1895
01:17:59,520 --> 01:18:01,360
looking for the value of this field go

1896
01:18:01,360 --> 01:18:04,800
find it in for as a variable of the same

1897
01:18:04,800 --> 01:18:05,199
name

1898
01:18:05,199 --> 01:18:07,760
in the same scope so it's like oh yeah

1899
01:18:07,760 --> 01:18:08,640
there is a name

1900
01:18:08,640 --> 01:18:10,640
variable i'll just use that an id

1901
01:18:10,640 --> 01:18:12,159
variable i'll just use that

1902
01:18:12,159 --> 01:18:13,840
and then instance use it so it kind of

1903
01:18:13,840 --> 01:18:16,800
saves you some typing

1904
01:18:17,920 --> 01:18:21,600
so we have this impul and notice we do

1905
01:18:21,600 --> 01:18:23,120
the colon colon here

1906
01:18:23,120 --> 01:18:26,320
again this is because

1907
01:18:26,320 --> 01:18:29,040
this is not an instance of employee this

1908
01:18:29,040 --> 01:18:29,920
is a static

1909
01:18:29,920 --> 01:18:33,520
employee but um you'll see

1910
01:18:33,520 --> 01:18:36,159
the difference here in a second um

1911
01:18:36,159 --> 01:18:37,840
really the key is

1912
01:18:37,840 --> 01:18:39,440
is there already something that was

1913
01:18:39,440 --> 01:18:41,040
created is there already a value that

1914
01:18:41,040 --> 01:18:42,239
we're working with

1915
01:18:42,239 --> 01:18:46,000
if not then we'll just call into

1916
01:18:46,000 --> 01:18:49,120
this impul this this

1917
01:18:49,120 --> 01:18:53,440
the the methods that are on

1918
01:18:53,440 --> 01:18:56,400
this um this top level i don't know i'm

1919
01:18:56,400 --> 01:18:57,679
trying to figure out an

1920
01:18:57,679 --> 01:19:00,159
uh easier way of saying it but i think

1921
01:19:00,159 --> 01:19:00,960
there's like

1922
01:19:00,960 --> 01:19:02,320
the things that are methods and the

1923
01:19:02,320 --> 01:19:05,280
things that aren't methods on an

1924
01:19:05,280 --> 01:19:08,560
instance of an object we'll see

1925
01:19:08,560 --> 01:19:10,480
we'll see it visually here in one second

1926
01:19:10,480 --> 01:19:13,280
okay so we've made

1927
01:19:13,280 --> 01:19:17,040
our new to give us employees

1928
01:19:17,040 --> 01:19:19,120
right so we can create values of

1929
01:19:19,120 --> 01:19:21,040
employees this way

1930
01:19:21,040 --> 01:19:22,800
let's make a method that actually uses

1931
01:19:22,800 --> 01:19:25,040
this

1932
01:19:25,360 --> 01:19:27,520
one common type of method would be a

1933
01:19:27,520 --> 01:19:29,360
getter let's just make it getter

1934
01:19:29,360 --> 01:19:32,400
for name

1935
01:19:32,560 --> 01:19:34,159
right so you might be tempted to write

1936
01:19:34,159 --> 01:19:36,800
it like this and get the string out this

1937
01:19:36,800 --> 01:19:39,040
way

1938
01:19:40,080 --> 01:19:43,199
and then return the string

1939
01:19:43,199 --> 01:19:47,440
the problem is there's no this here

1940
01:19:47,440 --> 01:19:50,560
right we don't like rust doesn't support

1941
01:19:50,560 --> 01:19:51,679
this

1942
01:19:51,679 --> 01:19:55,120
um which would be in an instance this is

1943
01:19:55,120 --> 01:19:56,320
implied

1944
01:19:56,320 --> 01:19:58,640
that there's this this thing and then i

1945
01:19:58,640 --> 01:19:59,840
can dot into this

1946
01:19:59,840 --> 01:20:02,880
and get the value out

1947
01:20:02,880 --> 01:20:06,480
so i use what's called self

1948
01:20:06,480 --> 01:20:10,000
and self is a way for this function

1949
01:20:10,000 --> 01:20:13,920
to refer to what was

1950
01:20:13,920 --> 01:20:17,040
kind of the the instance of this

1951
01:20:17,040 --> 01:20:21,120
employee class or employee struct

1952
01:20:27,360 --> 01:20:30,320
so i can say self.name and then that

1953
01:20:30,320 --> 01:20:31,440
will return

1954
01:20:31,440 --> 01:20:34,400
the string but we're about to get a

1955
01:20:34,400 --> 01:20:34,880
little

1956
01:20:34,880 --> 01:20:38,080
nasty surprise as we do this

1957
01:20:38,080 --> 01:20:40,880
and that's totally okay so this

1958
01:20:40,880 --> 01:20:42,000
self.name

1959
01:20:42,000 --> 01:20:45,120
is indeed a way of referencing in fact

1960
01:20:45,120 --> 01:20:45,520
but

1961
01:20:45,520 --> 01:20:48,960
before we do that let's actually do um

1962
01:20:48,960 --> 01:20:50,480
i'm going to change this real quick but

1963
01:20:50,480 --> 01:20:52,080
we'll go back

1964
01:20:52,080 --> 01:20:56,320
64 id

1965
01:20:56,320 --> 01:20:59,199
and that works

1966
01:20:59,520 --> 01:21:01,840
give you a second to think about why

1967
01:21:01,840 --> 01:21:02,639
would one

1968
01:21:02,639 --> 01:21:05,679
work and one not work but yeah if we

1969
01:21:05,679 --> 01:21:06,400
make an

1970
01:21:06,400 --> 01:21:09,440
uh a getter for id to return just the

1971
01:21:09,440 --> 01:21:10,560
value

1972
01:21:10,560 --> 01:21:14,000
for the id from this from the struct

1973
01:21:14,000 --> 01:21:16,880
this works okay so we can call instead

1974
01:21:16,880 --> 01:21:17,120
of

1975
01:21:17,120 --> 01:21:20,719
employee dot id we can call it like this

1976
01:21:20,719 --> 01:21:23,920
and call the getter instead

1977
01:21:24,239 --> 01:21:26,880
and that gives us our value but when we

1978
01:21:26,880 --> 01:21:29,040
try to do this with the string

1979
01:21:29,040 --> 01:21:31,840
it didn't work so let's look at that

1980
01:21:31,840 --> 01:21:33,280
again

1981
01:21:33,280 --> 01:21:36,719
so we'll say name same same pattern same

1982
01:21:36,719 --> 01:21:38,880
exact everything

1983
01:21:38,880 --> 01:21:42,639
self dot aim but then this one

1984
01:21:42,639 --> 01:21:44,639
once i hit save you'll see that it

1985
01:21:44,639 --> 01:21:46,719
doesn't work let's hover this and see

1986
01:21:46,719 --> 01:21:47,600
why

1987
01:21:47,600 --> 01:21:51,280
it says cannot move out of self.name

1988
01:21:51,280 --> 01:21:52,159
which is behind a

1989
01:21:52,159 --> 01:21:54,800
shared reference move occurs we've got

1990
01:21:54,800 --> 01:21:55,760
self.name

1991
01:21:55,760 --> 01:21:58,639
has type string which does not implement

1992
01:21:58,639 --> 01:22:00,080
the copy trait

1993
01:22:00,080 --> 01:22:02,320
now we haven't really seen traits just

1994
01:22:02,320 --> 01:22:04,320
yet though we've kind of hinted

1995
01:22:04,320 --> 01:22:07,840
at this ability to give types

1996
01:22:07,840 --> 01:22:10,719
new functionality and it's saying string

1997
01:22:10,719 --> 01:22:12,320
does not have this functionality it

1998
01:22:12,320 --> 01:22:13,840
cannot just be

1999
01:22:13,840 --> 01:22:17,600
copied and copy here means

2000
01:22:17,600 --> 01:22:22,159
that if i refer to this value that i can

2001
01:22:22,159 --> 01:22:25,840
without any additional code

2002
01:22:25,840 --> 01:22:28,560
on the user's part i know that it's safe

2003
01:22:28,560 --> 01:22:30,639
to just

2004
01:22:30,639 --> 01:22:33,520
run a function and get the result out

2005
01:22:33,520 --> 01:22:34,719
and use the result

2006
01:22:34,719 --> 01:22:37,360
behind the scenes that's called copy and

2007
01:22:37,360 --> 01:22:39,520
generally it's for

2008
01:22:39,520 --> 01:22:42,480
types that are

2009
01:22:42,960 --> 01:22:45,679
likely based on the stack they're very

2010
01:22:45,679 --> 01:22:47,440
simple types generally

2011
01:22:47,440 --> 01:22:51,199
so here an i-64 and an i-64

2012
01:22:51,199 --> 01:22:53,920
is the same right there's no there's

2013
01:22:53,920 --> 01:22:54,480
nothing

2014
01:22:54,480 --> 01:22:58,080
um no heap allocation

2015
01:22:58,080 --> 01:22:59,440
nothing about it is really that

2016
01:22:59,440 --> 01:23:01,199
complicated and in fact

2017
01:23:01,199 --> 01:23:04,000
on the hardware side in a register i can

2018
01:23:04,000 --> 01:23:04,719
just store

2019
01:23:04,719 --> 01:23:06,960
an i-64 and then when i say move to this

2020
01:23:06,960 --> 01:23:08,239
other register

2021
01:23:08,239 --> 01:23:10,800
that's a copy right we're not literally

2022
01:23:10,800 --> 01:23:12,080
removing it from one

2023
01:23:12,080 --> 01:23:13,679
register to another and putting it in

2024
01:23:13,679 --> 01:23:15,840
the second register

2025
01:23:15,840 --> 01:23:18,960
it's the same kind of idea on the

2026
01:23:18,960 --> 01:23:21,199
on the low low level there are a certain

2027
01:23:21,199 --> 01:23:22,159
set of types

2028
01:23:22,159 --> 01:23:25,600
that copy effortlessly in hardware

2029
01:23:25,600 --> 01:23:28,639
and i-64 is one of those so in this case

2030
01:23:28,639 --> 01:23:31,199
it's saying

2031
01:23:31,679 --> 01:23:34,000
for these set of types these can be

2032
01:23:34,000 --> 01:23:35,760
copied by default

2033
01:23:35,760 --> 01:23:38,639
for this type this capital string type

2034
01:23:38,639 --> 01:23:39,760
it uses the heap

2035
01:23:39,760 --> 01:23:43,840
like we talked about before it is not

2036
01:23:43,840 --> 01:23:47,760
as easy as you know a little

2037
01:23:47,760 --> 01:23:50,239
doing a little bit twiddle in memory

2038
01:23:50,239 --> 01:23:52,000
this is something pointing at heap and

2039
01:23:52,000 --> 01:23:54,639
if we just naively copied

2040
01:23:54,639 --> 01:23:57,040
you know say this this thing is pointing

2041
01:23:57,040 --> 01:23:57,760
at the

2042
01:23:57,760 --> 01:24:00,000
i'm trying to point it to the camera so

2043
01:24:00,000 --> 01:24:01,360
we've got two things

2044
01:24:01,360 --> 01:24:02,960
let's say we got one thing pointing into

2045
01:24:02,960 --> 01:24:05,600
somewhere in the heap if we naively make

2046
01:24:05,600 --> 01:24:07,199
something else that points at the same

2047
01:24:07,199 --> 01:24:09,120
thing in the heap now we have

2048
01:24:09,120 --> 01:24:12,400
two owners for the same piece of memory

2049
01:24:12,400 --> 01:24:15,120
and that is a no no you cannot do that

2050
01:24:15,120 --> 01:24:17,360
in rest we need to

2051
01:24:17,360 --> 01:24:21,280
give clear ownership so the struct owns

2052
01:24:21,280 --> 01:24:23,840
one copy and as you can kind of see

2053
01:24:23,840 --> 01:24:24,800
where i'm going

2054
01:24:24,800 --> 01:24:27,440
we need a way of saying create me a

2055
01:24:27,440 --> 01:24:29,440
whole separate copy

2056
01:24:29,440 --> 01:24:31,920
and then give that to whoever called

2057
01:24:31,920 --> 01:24:34,480
this function

2058
01:24:35,440 --> 01:24:37,760
right so that is why this is erroring

2059
01:24:37,760 --> 01:24:38,960
it's saying i can't

2060
01:24:38,960 --> 01:24:41,840
do this for you for free you need to do

2061
01:24:41,840 --> 01:24:43,360
the extra step

2062
01:24:43,360 --> 01:24:47,760
to give a copy of this somewhere else

2063
01:24:49,520 --> 01:24:54,239
so i'll say clone

2064
01:24:54,239 --> 01:24:58,400
which we have not used before

2065
01:24:58,400 --> 01:25:01,440
but clone is going to do

2066
01:25:01,440 --> 01:25:03,840
that copy it's going to do a what's

2067
01:25:03,840 --> 01:25:04,880
called a clone

2068
01:25:04,880 --> 01:25:08,800
which is like a deep copy of the value

2069
01:25:08,800 --> 01:25:11,520
and the you know what that pointer is

2070
01:25:11,520 --> 01:25:12,800
pointing at on the heap

2071
01:25:12,800 --> 01:25:15,600
it's going to give me two separate

2072
01:25:15,600 --> 01:25:16,800
versions of that

2073
01:25:16,800 --> 01:25:19,199
right the original one and its heap

2074
01:25:19,199 --> 01:25:20,239
value

2075
01:25:20,239 --> 01:25:22,480
and the new one and its new heap value

2076
01:25:22,480 --> 01:25:24,480
that has all the same contents as the

2077
01:25:24,480 --> 01:25:26,000
other one right but two separate

2078
01:25:26,000 --> 01:25:28,639
ones and that's the important thing so

2079
01:25:28,639 --> 01:25:29,920
you've got

2080
01:25:29,920 --> 01:25:33,199
two owners and two

2081
01:25:33,199 --> 01:25:37,600
roughly equivalent values on the heap

2082
01:25:37,600 --> 01:25:39,120
now that we've cloned that this is

2083
01:25:39,120 --> 01:25:41,040
correct so we're saying every time we

2084
01:25:41,040 --> 01:25:42,000
call new

2085
01:25:42,000 --> 01:25:45,199
we get a new string on the heap so you

2086
01:25:45,199 --> 01:25:46,320
might feel that this

2087
01:25:46,320 --> 01:25:48,000
if you've done a bit of optimization

2088
01:25:48,000 --> 01:25:49,840
work or you're you know coming from cnc

2089
01:25:49,840 --> 01:25:51,520
plus plus you might think whoa

2090
01:25:51,520 --> 01:25:52,960
almost sweat a little bit if you're

2091
01:25:52,960 --> 01:25:54,880
going to do an allocation every time i

2092
01:25:54,880 --> 01:25:56,080
call this

2093
01:25:56,080 --> 01:25:57,440
if you're coming from other languages

2094
01:25:57,440 --> 01:25:59,199
maybe not so big a deal you just do this

2095
01:25:59,199 --> 01:26:01,520
without thinking about it

2096
01:26:01,520 --> 01:26:02,880
i'll show you here how to get around

2097
01:26:02,880 --> 01:26:05,760
this in one second

2098
01:26:06,320 --> 01:26:09,040
but yeah just for now we're gonna every

2099
01:26:09,040 --> 01:26:10,480
time we call

2100
01:26:10,480 --> 01:26:12,719
this getter we're just gonna create a

2101
01:26:12,719 --> 01:26:13,920
new copy

2102
01:26:13,920 --> 01:26:15,760
because it's gonna get us around having

2103
01:26:15,760 --> 01:26:17,280
to worry about that

2104
01:26:17,280 --> 01:26:20,840
ownership the ownership and borrow

2105
01:26:20,840 --> 01:26:22,719
checking

2106
01:26:22,719 --> 01:26:24,639
and as a result we can go ahead and run

2107
01:26:24,639 --> 01:26:26,880
this

2108
01:26:35,120 --> 01:26:36,960
all right there we go now we've made two

2109
01:26:36,960 --> 01:26:39,120
getters one that can

2110
01:26:39,120 --> 01:26:40,960
get us the name one that can get us the

2111
01:26:40,960 --> 01:26:43,280
id

2112
01:26:43,920 --> 01:26:46,560
any questions

2113
01:26:49,040 --> 01:26:52,960
cool so

2114
01:26:52,960 --> 01:26:55,199
let's actually we're going to start

2115
01:26:55,199 --> 01:26:57,280
playing a little bit with the borrow

2116
01:26:57,280 --> 01:27:00,159
system and because like i said at the

2117
01:27:00,159 --> 01:27:00,880
beginning

2118
01:27:00,880 --> 01:27:04,080
of the stream you know after i gave some

2119
01:27:04,080 --> 01:27:05,840
of the uh

2120
01:27:05,840 --> 01:27:07,920
the basics i think one of the things

2121
01:27:07,920 --> 01:27:08,960
that people really

2122
01:27:08,960 --> 01:27:12,159
trip over is the borrow system

2123
01:27:12,159 --> 01:27:15,040
and i want to talk about that and unpack

2124
01:27:15,040 --> 01:27:15,920
what's going on

2125
01:27:15,920 --> 01:27:18,239
underneath the surface a bit and then

2126
01:27:18,239 --> 01:27:20,480
we'll look at a few

2127
01:27:20,480 --> 01:27:23,440
techniques that you can use to work with

2128
01:27:23,440 --> 01:27:25,440
bio-checking errors that

2129
01:27:25,440 --> 01:27:28,400
come up in practice

2130
01:27:29,120 --> 01:27:33,760
first let me talk about what um

2131
01:27:33,760 --> 01:27:37,199
what this ampersand means because it's

2132
01:27:37,199 --> 01:27:40,639
this ampersand is an important thing to

2133
01:27:40,639 --> 01:27:45,280
understand as you understand russ code

2134
01:27:45,520 --> 01:27:50,560
and what we're saying here is that

2135
01:27:53,440 --> 01:27:56,719
when we talk about ownership the way to

2136
01:27:56,719 --> 01:27:58,000
think about ownership and

2137
01:27:58,000 --> 01:28:01,280
rust another way to think about it

2138
01:28:01,280 --> 01:28:04,800
is to say that an owner is who is

2139
01:28:04,800 --> 01:28:06,880
responsible for destroying

2140
01:28:06,880 --> 01:28:10,239
or deleting that value

2141
01:28:10,239 --> 01:28:13,360
so when i look up here

2142
01:28:13,360 --> 01:28:15,120
i can see because there are no

2143
01:28:15,120 --> 01:28:17,520
ampersands anywhere

2144
01:28:17,520 --> 01:28:20,880
that when new is called that ownership

2145
01:28:20,880 --> 01:28:24,080
passes into new for the string

2146
01:28:24,080 --> 01:28:26,800
and this id

2147
01:28:27,440 --> 01:28:32,560
excuse me ownership passes into here

2148
01:28:32,560 --> 01:28:36,159
and any ownership that new

2149
01:28:36,159 --> 01:28:40,320
has at the end of that function

2150
01:28:40,480 --> 01:28:44,159
it will need to delete those values

2151
01:28:44,159 --> 01:28:47,440
now in this particular case it doesn't

2152
01:28:47,440 --> 01:28:49,760
have to

2153
01:28:49,840 --> 01:28:52,480
and the reason is because these two

2154
01:28:52,480 --> 01:28:53,280
values

2155
01:28:53,280 --> 01:28:56,480
name and id are going to become

2156
01:28:56,480 --> 01:29:00,159
owned by this struct so this is going to

2157
01:29:00,159 --> 01:29:02,400
take ownership of name and id

2158
01:29:02,400 --> 01:29:04,320
because the struct itself needs to get

2159
01:29:04,320 --> 01:29:06,480
built right so those are going to come

2160
01:29:06,480 --> 01:29:07,120
in

2161
01:29:07,120 --> 01:29:08,400
they're going to go right into the

2162
01:29:08,400 --> 01:29:10,560
structure and then the structure will

2163
01:29:10,560 --> 01:29:11,199
get

2164
01:29:11,199 --> 01:29:14,400
returned so after

2165
01:29:14,400 --> 01:29:18,560
if i tried to do this

2166
01:29:18,800 --> 01:29:23,040
let's say i tried to do let employee

2167
01:29:23,040 --> 01:29:27,120
equals oops this

2168
01:29:27,120 --> 01:29:31,840
and then we'll return employee down here

2169
01:29:31,840 --> 01:29:34,880
but let's say that i tried to also

2170
01:29:34,880 --> 01:29:37,280
uh let's see if we can just even try to

2171
01:29:37,280 --> 01:29:38,000
print out

2172
01:29:38,000 --> 01:29:42,880
what name is here okay

2173
01:29:42,960 --> 01:29:44,480
you can see we get an error well we

2174
01:29:44,480 --> 01:29:46,320
normally wouldn't get an error

2175
01:29:46,320 --> 01:29:49,600
right we can always print out strings

2176
01:29:49,600 --> 01:29:52,480
but what we've done is we've said take

2177
01:29:52,480 --> 01:29:53,600
name and id

2178
01:29:53,600 --> 01:29:55,520
take those two values and stick them

2179
01:29:55,520 --> 01:29:57,280
into the struct

2180
01:29:57,280 --> 01:29:59,280
right now we have a struct that owns

2181
01:29:59,280 --> 01:30:01,360
those values

2182
01:30:01,360 --> 01:30:03,600
and that's sitting right here in this

2183
01:30:03,600 --> 01:30:05,040
variable employee

2184
01:30:05,040 --> 01:30:08,320
right so employee owns those values

2185
01:30:08,320 --> 01:30:11,600
name because it doesn't have copy

2186
01:30:11,600 --> 01:30:14,639
right it's not that simple copy thing

2187
01:30:14,639 --> 01:30:18,880
is com is gone

2188
01:30:18,880 --> 01:30:22,560
for for from the perspective of new

2189
01:30:22,560 --> 01:30:24,400
at this point in time i have just taken

2190
01:30:24,400 --> 01:30:26,719
ownership and said here you go

2191
01:30:26,719 --> 01:30:29,760
right it's kind of like i i have a book

2192
01:30:29,760 --> 01:30:32,880
and i lent the book to you

2193
01:30:32,880 --> 01:30:34,560
uh but in this case i just gave you the

2194
01:30:34,560 --> 01:30:36,239
book and then i tried to read the book

2195
01:30:36,239 --> 01:30:37,440
later but i don't have the book

2196
01:30:37,440 --> 01:30:40,880
i just gave it to you right so employee

2197
01:30:40,880 --> 01:30:44,639
now has name and id

2198
01:30:45,360 --> 01:30:48,239
it owns these and so you can kind of

2199
01:30:48,239 --> 01:30:48,639
think

2200
01:30:48,639 --> 01:30:51,040
all of that goes up into the employee

2201
01:30:51,040 --> 01:30:52,400
and that's gone

2202
01:30:52,400 --> 01:30:55,679
right name is gone and then i when i try

2203
01:30:55,679 --> 01:30:56,480
to return it

2204
01:30:56,480 --> 01:30:58,719
that's fine i can return the value

2205
01:30:58,719 --> 01:31:00,000
that's that's okay

2206
01:31:00,000 --> 01:31:02,880
the error is referring to something that

2207
01:31:02,880 --> 01:31:06,000
i have already given away

2208
01:31:08,320 --> 01:31:09,760
so where were we oh yeah talking about

2209
01:31:09,760 --> 01:31:12,320
ownership and

2210
01:31:12,320 --> 01:31:16,000
ownership really is who gets to delete

2211
01:31:16,000 --> 01:31:19,040
it and who gets to use it

2212
01:31:19,040 --> 01:31:21,840
all right so if i given up ownership by

2213
01:31:21,840 --> 01:31:23,120
giving it to something else like

2214
01:31:23,120 --> 01:31:23,840
employee

2215
01:31:23,840 --> 01:31:27,199
i don't get to use it anymore and

2216
01:31:27,199 --> 01:31:30,400
at the end of this you know this

2217
01:31:30,400 --> 01:31:30,880
function

2218
01:31:30,880 --> 01:31:32,480
now is correct because i'm not using

2219
01:31:32,480 --> 01:31:35,679
something that i gave up ownership to

2220
01:31:35,679 --> 01:31:38,960
the um there's nothing to delete at the

2221
01:31:38,960 --> 01:31:39,440
end

2222
01:31:39,440 --> 01:31:42,320
right in this particular example had i

2223
01:31:42,320 --> 01:31:43,679
not returned

2224
01:31:43,679 --> 01:31:47,280
like had i not done this

2225
01:31:47,280 --> 01:31:49,120
let's imagine that new looks like this

2226
01:31:49,120 --> 01:31:51,520
instead

2227
01:31:51,679 --> 01:31:55,679
right if it looked like that then

2228
01:31:55,679 --> 01:31:58,880
if i called this the name that came in

2229
01:31:58,880 --> 01:32:01,199
and the id that came in would get

2230
01:32:01,199 --> 01:32:03,199
deleted at the end of this function

2231
01:32:03,199 --> 01:32:06,639
right new owns both of those values

2232
01:32:06,639 --> 01:32:09,199
and once the function finishes it's

2233
01:32:09,199 --> 01:32:11,040
responsible for cleaning them up

2234
01:32:11,040 --> 01:32:15,280
now id is trivial just like it's a copy

2235
01:32:15,280 --> 01:32:18,800
a copyable simple type deleting an i64

2236
01:32:18,800 --> 01:32:19,920
is like a no op

2237
01:32:19,920 --> 01:32:23,120
right there's nothing to do but

2238
01:32:23,120 --> 01:32:25,360
name needs its memory freed right it's

2239
01:32:25,360 --> 01:32:26,880
pointing at somewhere in the heap

2240
01:32:26,880 --> 01:32:28,239
it actually needs to have that memory

2241
01:32:28,239 --> 01:32:30,000
freed and this is how

2242
01:32:30,000 --> 01:32:33,040
when people say rust does

2243
01:32:33,040 --> 01:32:35,600
manual memory management this is the

2244
01:32:35,600 --> 01:32:37,760
kind of thing that they're saying

2245
01:32:37,760 --> 01:32:40,880
underneath the surface rust is managing

2246
01:32:40,880 --> 01:32:44,239
that memory with your help

2247
01:32:44,239 --> 01:32:46,560
so if you say this takes ownership it

2248
01:32:46,560 --> 01:32:48,560
knows at the end of this function

2249
01:32:48,560 --> 01:32:51,120
it needs to call something behind the

2250
01:32:51,120 --> 01:32:51,760
scenes

2251
01:32:51,760 --> 01:32:54,000
right it's called the drop trait if

2252
01:32:54,000 --> 01:32:56,000
anyone wants to go look it up

2253
01:32:56,000 --> 01:32:58,480
that will go and clean up that memory so

2254
01:32:58,480 --> 01:32:59,040
string

2255
01:32:59,040 --> 01:33:02,320
needs cleanup and

2256
01:33:02,320 --> 01:33:03,920
you know because again it's got that

2257
01:33:03,920 --> 01:33:05,440
pointer to the heat memory that's a

2258
01:33:05,440 --> 01:33:06,719
string of characters

2259
01:33:06,719 --> 01:33:09,679
no one knows how how big it is um until

2260
01:33:09,679 --> 01:33:11,679
you're running this code

2261
01:33:11,679 --> 01:33:14,000
so it needs to go and delete those that

2262
01:33:14,000 --> 01:33:15,040
that memory for you

2263
01:33:15,040 --> 01:33:18,480
that's really where ownership comes in

2264
01:33:18,480 --> 01:33:22,159
again is who has to delete this

2265
01:33:22,159 --> 01:33:25,280
or who owns the ability to access this

2266
01:33:25,280 --> 01:33:28,560
that's another way to think about it

2267
01:33:28,560 --> 01:33:32,159
so getting that in mind that when values

2268
01:33:32,159 --> 01:33:33,120
come in

2269
01:33:33,120 --> 01:33:36,719
to our functions into the structures

2270
01:33:36,719 --> 01:33:40,159
um that when they are

2271
01:33:40,159 --> 01:33:42,159
when they don't have an ampersand i need

2272
01:33:42,159 --> 01:33:43,520
a better name for that

2273
01:33:43,520 --> 01:33:45,440
ampersand list doesn't really sound very

2274
01:33:45,440 --> 01:33:47,679
nice but if they don't have an ampersand

2275
01:33:47,679 --> 01:33:48,560
that means

2276
01:33:48,560 --> 01:33:50,960
whoever is getting this value and we can

2277
01:33:50,960 --> 01:33:51,679
see up here

2278
01:33:51,679 --> 01:33:55,199
same thing right employee gets ownership

2279
01:33:55,199 --> 01:33:57,520
of this value when it gets put in

2280
01:33:57,520 --> 01:33:59,520
this function gets ownership of name

2281
01:33:59,520 --> 01:34:02,400
when it gets called

2282
01:34:02,639 --> 01:34:05,199
to avoid that right you're not always

2283
01:34:05,199 --> 01:34:07,040
going to want that

2284
01:34:07,040 --> 01:34:11,199
you use a borrow and this ampersand

2285
01:34:11,199 --> 01:34:15,040
is that it's saying i don't get to own

2286
01:34:15,040 --> 01:34:17,199
self like at the end of this getter i'm

2287
01:34:17,199 --> 01:34:18,480
not deleting self

2288
01:34:18,480 --> 01:34:21,120
right that would be bad a method that

2289
01:34:21,120 --> 01:34:22,639
deletes the

2290
01:34:22,639 --> 01:34:26,639
the the um the object itself

2291
01:34:26,639 --> 01:34:28,880
better be a very specific method that is

2292
01:34:28,880 --> 01:34:30,719
not not something you generally want to

2293
01:34:30,719 --> 01:34:31,600
do

2294
01:34:31,600 --> 01:34:35,280
so this ampersand is saying you get

2295
01:34:35,280 --> 01:34:39,199
temporary ownership of this

2296
01:34:39,199 --> 01:34:42,800
object or of this value

2297
01:34:42,800 --> 01:34:45,520
and at the end of the function rather

2298
01:34:45,520 --> 01:34:47,440
than deleting which would be like

2299
01:34:47,440 --> 01:34:50,639
full ownership it's just to borrow so i

2300
01:34:50,639 --> 01:34:51,520
release

2301
01:34:51,520 --> 01:34:54,639
ownership rather than deleting that's

2302
01:34:54,639 --> 01:34:56,480
what this is saying

2303
01:34:56,480 --> 01:34:59,920
so it comes in and says this ampersa

2304
01:34:59,920 --> 01:35:02,880
this uh self is something that i get to

2305
01:35:02,880 --> 01:35:03,920
use

2306
01:35:03,920 --> 01:35:05,360
there's there's some restrictions in

2307
01:35:05,360 --> 01:35:07,679
what i can do to it in this particular

2308
01:35:07,679 --> 01:35:08,960
case i can't be

2309
01:35:08,960 --> 01:35:10,880
i can't be mutating it or anything like

2310
01:35:10,880 --> 01:35:12,719
i can't be changing values in it

2311
01:35:12,719 --> 01:35:15,440
all i can do is just look into it i can

2312
01:35:15,440 --> 01:35:17,280
peer into it i can get some values out

2313
01:35:17,280 --> 01:35:18,719
here you see we go

2314
01:35:18,719 --> 01:35:21,760
self dot name no problem we can go and

2315
01:35:21,760 --> 01:35:23,840
read a value out

2316
01:35:23,840 --> 01:35:27,840
and once we do we can use that value in

2317
01:35:27,840 --> 01:35:28,560
some way

2318
01:35:28,560 --> 01:35:30,880
here we're calling that method clone on

2319
01:35:30,880 --> 01:35:31,679
the result

2320
01:35:31,679 --> 01:35:34,159
and getting us a new string out totally

2321
01:35:34,159 --> 01:35:34,800
fair game

2322
01:35:34,800 --> 01:35:36,800
we can do that at the end of this

2323
01:35:36,800 --> 01:35:37,840
function

2324
01:35:37,840 --> 01:35:42,000
self the ownership of self passes um

2325
01:35:42,000 --> 01:35:44,000
passes back out or you could think of it

2326
01:35:44,000 --> 01:35:45,600
a different way like

2327
01:35:45,600 --> 01:35:49,520
it's like a a promise to let go of it or

2328
01:35:49,520 --> 01:35:50,320
something like that

2329
01:35:50,320 --> 01:35:53,040
right so i lent it to you you give it

2330
01:35:53,040 --> 01:35:54,080
back to me

2331
01:35:54,080 --> 01:35:56,080
that's what we're trying to say here

2332
01:35:56,080 --> 01:35:57,600
name uh

2333
01:35:57,600 --> 01:35:59,600
we'll give self back to whoever called

2334
01:35:59,600 --> 01:36:03,119
us so when we're calling down here

2335
01:36:03,119 --> 01:36:05,360
we make our employee object i keep

2336
01:36:05,360 --> 01:36:06,560
saying object

2337
01:36:06,560 --> 01:36:09,600
think struct when i say object but

2338
01:36:09,600 --> 01:36:11,679
generally in your mind that's kind of

2339
01:36:11,679 --> 01:36:13,440
what it is underneath the surface right

2340
01:36:13,440 --> 01:36:15,600
this instance of employee the struct

2341
01:36:15,600 --> 01:36:16,719
object this

2342
01:36:16,719 --> 01:36:21,119
uh struct employee employee struct value

2343
01:36:21,119 --> 01:36:23,360
right so we have that and when we call

2344
01:36:23,360 --> 01:36:25,520
those getters

2345
01:36:25,520 --> 01:36:28,800
name will borrow this

2346
01:36:28,800 --> 01:36:32,639
okay so this will become the self value

2347
01:36:32,639 --> 01:36:36,719
but because we're saying ampersand self

2348
01:36:36,719 --> 01:36:39,760
we're saying employee comes in

2349
01:36:39,760 --> 01:36:41,199
i get to look at the values and

2350
01:36:41,199 --> 01:36:43,199
immediately when it finishes

2351
01:36:43,199 --> 01:36:44,960
i just keep going right where i was

2352
01:36:44,960 --> 01:36:46,719
before maine never

2353
01:36:46,719 --> 01:36:51,440
loses ownership right it just kind of

2354
01:36:51,440 --> 01:36:54,080
kind of lets other things borrow it but

2355
01:36:54,080 --> 01:36:56,000
the responsibility to destroy like we're

2356
01:36:56,000 --> 01:36:56,880
saying

2357
01:36:56,880 --> 01:36:59,920
ownership is around who gets to who

2358
01:36:59,920 --> 01:37:01,679
who must destroy this at the end of the

2359
01:37:01,679 --> 01:37:03,280
function who must clean up the memory

2360
01:37:03,280 --> 01:37:04,719
etc

2361
01:37:04,719 --> 01:37:06,880
maine never loses that responsibility

2362
01:37:06,880 --> 01:37:08,159
it's always going to happen

2363
01:37:08,159 --> 01:37:10,960
at the end of maine

2364
01:37:11,920 --> 01:37:16,560
so that is um ampersand

2365
01:37:16,560 --> 01:37:20,159
so being able to call ampersand self

2366
01:37:20,159 --> 01:37:22,000
uh let's just actually real quick do

2367
01:37:22,000 --> 01:37:25,520
another another function to show this

2368
01:37:25,520 --> 01:37:31,360
um do we need to i mean just for clarity

2369
01:37:32,080 --> 01:37:35,679
borrow thing

2370
01:37:35,679 --> 01:37:40,159
and then this will take an employee now

2371
01:37:41,119 --> 01:37:43,360
if all we've said up to this point is

2372
01:37:43,360 --> 01:37:45,679
true

2373
01:37:45,840 --> 01:37:49,840
then if we do this

2374
01:37:51,440 --> 01:37:53,840
and we use the name that way we can use

2375
01:37:53,840 --> 01:37:56,320
it that way

2376
01:37:56,800 --> 01:37:59,840
and i say borrow

2377
01:37:59,840 --> 01:38:03,840
thing employee

2378
01:38:03,840 --> 01:38:05,679
yes the eagle-eyed among you saw that i

2379
01:38:05,679 --> 01:38:09,199
did do a typo and that was on purpose

2380
01:38:09,199 --> 01:38:11,119
so borrowing is not actually borrowing

2381
01:38:11,119 --> 01:38:12,239
yet right

2382
01:38:12,239 --> 01:38:15,600
this non-ampersand-less wait

2383
01:38:15,600 --> 01:38:17,920
ampersandless non-ampersand whatever you

2384
01:38:17,920 --> 01:38:19,199
want to call it

2385
01:38:19,199 --> 01:38:22,560
um yeah this is going to take full

2386
01:38:22,560 --> 01:38:27,360
ownership of employee so i called this

2387
01:38:27,360 --> 01:38:29,440
this thing and then immediately after

2388
01:38:29,440 --> 01:38:31,679
that it's like whoa whoa whoa

2389
01:38:31,679 --> 01:38:34,400
you moved it right moving means to give

2390
01:38:34,400 --> 01:38:36,480
ownership to something else

2391
01:38:36,480 --> 01:38:40,400
you gave ownership you moved that value

2392
01:38:40,400 --> 01:38:44,159
into being owned by this function

2393
01:38:44,159 --> 01:38:46,800
it's gone you don't get to use it

2394
01:38:46,800 --> 01:38:48,159
anymore

2395
01:38:48,159 --> 01:38:51,280
and to get rid of that error

2396
01:38:51,280 --> 01:38:54,719
we use the the ampersand and this will

2397
01:38:54,719 --> 01:38:58,239
again mean i get to use it for some

2398
01:38:58,239 --> 01:39:01,840
uh short duration i don't own it

2399
01:39:01,840 --> 01:39:05,360
right i just borrow it and

2400
01:39:05,360 --> 01:39:08,400
we have to change both the definition

2401
01:39:08,400 --> 01:39:10,719
of the function and also where it's

2402
01:39:10,719 --> 01:39:12,080
called so here

2403
01:39:12,080 --> 01:39:14,960
i use the ampersand again to denote this

2404
01:39:14,960 --> 01:39:15,760
is a borrow

2405
01:39:15,760 --> 01:39:18,480
not a move and it's you know in

2406
01:39:18,480 --> 01:39:20,080
designing the language i think

2407
01:39:20,080 --> 01:39:24,639
the rust designers are very clever to

2408
01:39:24,639 --> 01:39:27,040
make you have to put it both places

2409
01:39:27,040 --> 01:39:28,080
because

2410
01:39:28,080 --> 01:39:29,840
whether i i'm looking in this part of

2411
01:39:29,840 --> 01:39:31,679
the definition you know say this is on

2412
01:39:31,679 --> 01:39:32,560
like

2413
01:39:32,560 --> 01:39:35,040
file a somewhere and this is in file b

2414
01:39:35,040 --> 01:39:36,400
somewhere

2415
01:39:36,400 --> 01:39:39,440
regardless of if it's the definition or

2416
01:39:39,440 --> 01:39:41,760
the call site i always know

2417
01:39:41,760 --> 01:39:44,480
that this is getting borrowed i'm still

2418
01:39:44,480 --> 01:39:45,360
responsible

2419
01:39:45,360 --> 01:39:47,440
when this thing finishes running i'm

2420
01:39:47,440 --> 01:39:48,880
still responsible for employee after

2421
01:39:48,880 --> 01:39:50,480
that and i still have access to it

2422
01:39:50,480 --> 01:39:52,960
as well so there's the responsibility

2423
01:39:52,960 --> 01:39:54,159
and you know

2424
01:39:54,159 --> 01:39:55,840
the the power that comes along with that

2425
01:39:55,840 --> 01:39:58,560
responsibility

2426
01:40:00,639 --> 01:40:04,080
so that is employee and uh

2427
01:40:04,080 --> 01:40:05,600
borrowing that employee seeing a

2428
01:40:05,600 --> 01:40:09,760
function that that can borrow

2429
01:40:09,760 --> 01:40:12,719
this borrow

2430
01:40:13,199 --> 01:40:16,400
is actually there is a

2431
01:40:16,400 --> 01:40:18,880
us kind of a hidden value that goes

2432
01:40:18,880 --> 01:40:20,080
along with this

2433
01:40:20,080 --> 01:40:23,440
that says where like who owns this

2434
01:40:23,440 --> 01:40:26,000
you could think of it that way um how

2435
01:40:26,000 --> 01:40:27,679
long it will live

2436
01:40:27,679 --> 01:40:30,880
so it's called a lifetime and

2437
01:40:30,880 --> 01:40:33,280
if you get into borrow checking errors

2438
01:40:33,280 --> 01:40:34,000
you'll see

2439
01:40:34,000 --> 01:40:37,360
lifetime errors where

2440
01:40:37,360 --> 01:40:39,119
it says well this thing doesn't live

2441
01:40:39,119 --> 01:40:41,040
long enough for this and

2442
01:40:41,040 --> 01:40:43,679
and you'll have to kind of deal with

2443
01:40:43,679 --> 01:40:44,880
making sure that russ

2444
01:40:44,880 --> 01:40:47,760
understands that the lifetimes square up

2445
01:40:47,760 --> 01:40:48,080
like

2446
01:40:48,080 --> 01:40:50,560
this lives long enough to satisfy

2447
01:40:50,560 --> 01:40:53,760
whatever the issue is

2448
01:40:54,480 --> 01:40:56,320
let's actually try to get ourselves in a

2449
01:40:56,320 --> 01:40:57,679
bit of lifetime

2450
01:40:57,679 --> 01:41:01,679
error and then see if we can get back

2451
01:41:01,679 --> 01:41:03,119
out

2452
01:41:03,119 --> 01:41:05,520
so i'm going to get rid of this borrow

2453
01:41:05,520 --> 01:41:07,760
thing

2454
01:41:08,080 --> 01:41:10,880
and we'll get rid of this we have the

2455
01:41:10,880 --> 01:41:12,239
same pattern up here i just kind of

2456
01:41:12,239 --> 01:41:14,080
wanted to expand a little bit to see it

2457
01:41:14,080 --> 01:41:16,000
clear

2458
01:41:16,000 --> 01:41:19,520
and instead of turning string here

2459
01:41:19,520 --> 01:41:23,119
let's return and stir like we are going

2460
01:41:23,119 --> 01:41:24,239
to return

2461
01:41:24,239 --> 01:41:25,679
now that we now that we've seen

2462
01:41:25,679 --> 01:41:27,840
ampersand before

2463
01:41:27,840 --> 01:41:31,280
we get a sense for oh this is

2464
01:41:31,280 --> 01:41:35,360
like i don't really own this stir it's

2465
01:41:35,360 --> 01:41:37,760
owned by someone else somewhere else i

2466
01:41:37,760 --> 01:41:38,800
don't know where

2467
01:41:38,800 --> 01:41:42,239
necessarily but i know that

2468
01:41:42,239 --> 01:41:45,600
this this

2469
01:41:45,600 --> 01:41:48,000
string or this in this particular case

2470
01:41:48,000 --> 01:41:49,199
it's a

2471
01:41:49,199 --> 01:41:52,639
um a string slice like a

2472
01:41:52,639 --> 01:41:54,880
a pointer and a length in memory

2473
01:41:54,880 --> 01:41:56,880
somewhere pointing at some string of

2474
01:41:56,880 --> 01:41:59,520
characters somewhere

2475
01:41:59,520 --> 01:42:02,320
we don't know where

2476
01:42:02,560 --> 01:42:05,840
but it's owned by someone else

2477
01:42:05,840 --> 01:42:08,320
so that ampersand keeps us thinking

2478
01:42:08,320 --> 01:42:09,520
about that

2479
01:42:09,520 --> 01:42:11,760
the advantage here is that we don't have

2480
01:42:11,760 --> 01:42:14,880
to clone anymore

2481
01:42:14,880 --> 01:42:18,560
we can say um oh yeah

2482
01:42:18,560 --> 01:42:21,920
again we have to use the borrow

2483
01:42:22,480 --> 01:42:26,400
we can say go find

2484
01:42:26,400 --> 01:42:28,320
you know we've got a struct it's already

2485
01:42:28,320 --> 01:42:30,800
got that string in memory

2486
01:42:30,800 --> 01:42:34,159
go find where that is and then borrow

2487
01:42:34,159 --> 01:42:36,480
that string

2488
01:42:36,480 --> 01:42:40,639
right so whoever calls this

2489
01:42:40,639 --> 01:42:43,600
now has a borrow of it rather than you

2490
01:42:43,600 --> 01:42:44,000
know

2491
01:42:44,000 --> 01:42:47,040
two separate strings with two separate

2492
01:42:47,040 --> 01:42:48,719
copies in the heap

2493
01:42:48,719 --> 01:42:52,480
we have basically one copy in the heap

2494
01:42:52,480 --> 01:42:55,600
and two things pointing at it one that's

2495
01:42:55,600 --> 01:42:56,800
the owner

2496
01:42:56,800 --> 01:42:59,360
and one that's the borrower that makes

2497
01:42:59,360 --> 01:43:01,679
sense

2498
01:43:02,159 --> 01:43:05,280
and this cuts down on the amount of

2499
01:43:05,280 --> 01:43:09,360
work that the your runtime

2500
01:43:09,360 --> 01:43:12,400
application needs to do um

2501
01:43:12,400 --> 01:43:14,719
but at some you know you do have to

2502
01:43:14,719 --> 01:43:16,560
start understanding the borrow system a

2503
01:43:16,560 --> 01:43:18,800
little bit to be able to do this

2504
01:43:18,800 --> 01:43:22,000
where you know you can describe how who

2505
01:43:22,000 --> 01:43:22,480
owns

2506
01:43:22,480 --> 01:43:25,040
what and who's borrowing what to the

2507
01:43:25,040 --> 01:43:26,400
compiler

2508
01:43:26,400 --> 01:43:28,080
i think one of the areas where people

2509
01:43:28,080 --> 01:43:29,520
get into trouble

2510
01:43:29,520 --> 01:43:32,400
is if they get a little too fancy too

2511
01:43:32,400 --> 01:43:33,440
quickly

2512
01:43:33,440 --> 01:43:35,360
and don't quite understand the borrower

2513
01:43:35,360 --> 01:43:36,800
checker or

2514
01:43:36,800 --> 01:43:38,239
get themselves into a corner and i've

2515
01:43:38,239 --> 01:43:40,719
done this many many times i'm definitely

2516
01:43:40,719 --> 01:43:43,840
definitely just as guilty

2517
01:43:43,840 --> 01:43:48,159
i would generally tell people to use

2518
01:43:48,159 --> 01:43:50,480
things like clone

2519
01:43:50,480 --> 01:43:54,000
first like if you start borrowing

2520
01:43:54,000 --> 01:43:55,440
and if you start working with the

2521
01:43:55,440 --> 01:43:58,480
ownership system just

2522
01:43:58,480 --> 01:43:59,920
know that you're getting into a

2523
01:43:59,920 --> 01:44:01,600
territory where you're the

2524
01:44:01,600 --> 01:44:02,960
amount of rest that you need to

2525
01:44:02,960 --> 01:44:06,000
understand starts to go up a bit

2526
01:44:06,000 --> 01:44:07,600
but you can always use clone you can

2527
01:44:07,600 --> 01:44:10,560
always make those two copies of the heap

2528
01:44:10,560 --> 01:44:12,159
and i'll show a couple other things you

2529
01:44:12,159 --> 01:44:13,679
can do there's a thing called

2530
01:44:13,679 --> 01:44:16,719
arc arc or using

2531
01:44:16,719 --> 01:44:20,320
lock locks over values so that you can

2532
01:44:20,320 --> 01:44:23,040
not have to fight the borrower checker

2533
01:44:23,040 --> 01:44:23,920
quite so much

2534
01:44:23,920 --> 01:44:25,600
i'll show a couple of those here in a

2535
01:44:25,600 --> 01:44:27,119
few minutes

2536
01:44:27,119 --> 01:44:29,119
but i wanted to show what it looks like

2537
01:44:29,119 --> 01:44:30,400
to actually

2538
01:44:30,400 --> 01:44:32,400
work with the bar checker directly and

2539
01:44:32,400 --> 01:44:33,600
to use it in

2540
01:44:33,600 --> 01:44:38,000
the way it's kind of intended so

2541
01:44:38,000 --> 01:44:40,719
here i'm i've got that name in the

2542
01:44:40,719 --> 01:44:42,560
struct

2543
01:44:42,560 --> 01:44:45,840
and so

2544
01:44:45,840 --> 01:44:48,159
ampersand self sorry this is a good

2545
01:44:48,159 --> 01:44:49,760
clarifying question

2546
01:44:49,760 --> 01:44:52,880
so ampersand self.name means

2547
01:44:52,880 --> 01:44:56,159
ampersand self.name so like

2548
01:44:56,159 --> 01:44:58,480
this just to get some order of

2549
01:44:58,480 --> 01:44:59,840
operations clear

2550
01:44:59,840 --> 01:45:02,880
yes that's right it means this

2551
01:45:02,880 --> 01:45:06,400
it's like go find this member

2552
01:45:06,400 --> 01:45:09,920
and then let me borrow that member

2553
01:45:09,920 --> 01:45:12,960
yeah exactly it's not borrowing self and

2554
01:45:12,960 --> 01:45:13,360
then

2555
01:45:13,360 --> 01:45:16,080
dotting into that that's right if you

2556
01:45:16,080 --> 01:45:18,159
did

2557
01:45:18,159 --> 01:45:21,440
if you did do such a thing

2558
01:45:21,520 --> 01:45:24,080
like this

2559
01:45:26,560 --> 01:45:30,400
yep so what this does is saying

2560
01:45:30,400 --> 01:45:33,920
borrow self and then when i borrow self

2561
01:45:33,920 --> 01:45:37,280
dot into it and get the capital s string

2562
01:45:37,280 --> 01:45:39,040
out

2563
01:45:39,040 --> 01:45:41,679
yeah so we're not actually borrowing the

2564
01:45:41,679 --> 01:45:42,320
contents

2565
01:45:42,320 --> 01:45:44,719
inside the string or i should say

2566
01:45:44,719 --> 01:45:45,760
barring

2567
01:45:45,760 --> 01:45:47,360
when you borrow the string you're kind

2568
01:45:47,360 --> 01:45:48,960
of borrowing the contents it's a little

2569
01:45:48,960 --> 01:45:52,480
it's a little subtle but um yeah this is

2570
01:45:52,480 --> 01:45:54,400
this is getting the capital s string out

2571
01:45:54,400 --> 01:45:56,000
and what we want is

2572
01:45:56,000 --> 01:45:58,960
to borrow inside of that string so yeah

2573
01:45:58,960 --> 01:45:59,440
we use

2574
01:45:59,440 --> 01:46:02,719
this other form which is either

2575
01:46:02,719 --> 01:46:05,679
you can write it like this but generally

2576
01:46:05,679 --> 01:46:09,199
you write it the the way that i started

2577
01:46:09,199 --> 01:46:11,199
with the ampersand on the outside so

2578
01:46:11,199 --> 01:46:12,639
ampersand is like

2579
01:46:12,639 --> 01:46:15,360
low low priority everything else happens

2580
01:46:15,360 --> 01:46:16,400
first and then you

2581
01:46:16,400 --> 01:46:19,520
kind of borrow whatever the result of

2582
01:46:19,520 --> 01:46:20,400
that is

2583
01:46:20,400 --> 01:46:23,360
yeah that's a great question

2584
01:46:25,360 --> 01:46:28,480
all right so now that we've borrowed it

2585
01:46:28,480 --> 01:46:32,560
the result of id is still the same

2586
01:46:32,560 --> 01:46:35,040
the result of name there we go that's

2587
01:46:35,040 --> 01:46:36,080
what we not

2588
01:46:36,080 --> 01:46:38,560
is this ampersand stir epperson stir can

2589
01:46:38,560 --> 01:46:40,400
be used in a lot of the same ways that

2590
01:46:40,400 --> 01:46:41,760
strings can

2591
01:46:41,760 --> 01:46:43,600
but it's slightly more efficient right

2592
01:46:43,600 --> 01:46:46,000
we're not making that extra copy

2593
01:46:46,000 --> 01:46:49,119
we are using the same

2594
01:46:49,119 --> 01:46:52,239
the same set of characters or same bytes

2595
01:46:52,239 --> 01:46:53,440
in memory

2596
01:46:53,440 --> 01:46:56,800
that live inside of employee remember

2597
01:46:56,800 --> 01:46:57,360
that

2598
01:46:57,360 --> 01:46:59,679
we passed ownership of string and to

2599
01:46:59,679 --> 01:47:01,199
employee

2600
01:47:01,199 --> 01:47:05,040
that struct is sitting in memory and the

2601
01:47:05,040 --> 01:47:09,679
the characters are owned by that struct

2602
01:47:09,679 --> 01:47:13,119
and now we have a way of borrowing

2603
01:47:13,119 --> 01:47:15,520
those those characters just for long

2604
01:47:15,520 --> 01:47:17,440
enough to do this print out

2605
01:47:17,440 --> 01:47:19,679
and then at the end of this we'll give

2606
01:47:19,679 --> 01:47:21,040
up any borrow

2607
01:47:21,040 --> 01:47:24,960
that we've that we've temporarily had

2608
01:47:28,880 --> 01:47:31,199
okay

2609
01:47:33,119 --> 01:47:36,239
so i'm gonna do i'm gonna expand this

2610
01:47:36,239 --> 01:47:40,560
just one more step because i think that

2611
01:47:40,560 --> 01:47:43,440
when i saw this i think something

2612
01:47:43,440 --> 01:47:44,960
clicked for me that had not

2613
01:47:44,960 --> 01:47:47,119
clicked up into that point and i won't

2614
01:47:47,119 --> 01:47:48,800
at least show it if you don't

2615
01:47:48,800 --> 01:47:51,360
quite get it yet don't worry about it as

2616
01:47:51,360 --> 01:47:53,520
you play with rust i think

2617
01:47:53,520 --> 01:47:55,679
it will begin to make more sense and

2618
01:47:55,679 --> 01:47:58,239
hopefully it'll click for you

2619
01:47:58,239 --> 01:47:59,840
but i at least wanted to show it in this

2620
01:47:59,840 --> 01:48:02,080
stream because

2621
01:48:02,080 --> 01:48:04,880
once you see it i think it begins you

2622
01:48:04,880 --> 01:48:07,119
begin to think about

2623
01:48:07,119 --> 01:48:10,560
lifetimes as something

2624
01:48:10,560 --> 01:48:14,719
very much like a generic type like so

2625
01:48:14,719 --> 01:48:17,280
when we write name where we've got

2626
01:48:17,280 --> 01:48:18,480
ampersand self

2627
01:48:18,480 --> 01:48:22,080
and ampersand stir all right let's

2628
01:48:22,080 --> 01:48:24,880
string slice

2629
01:48:25,920 --> 01:48:28,480
you've got a borrow coming in and a

2630
01:48:28,480 --> 01:48:31,119
borrow going out

2631
01:48:31,119 --> 01:48:34,159
how do you know those are the same

2632
01:48:34,159 --> 01:48:36,560
borrow

2633
01:48:40,719 --> 01:48:43,600
yeah so there's something else going on

2634
01:48:43,600 --> 01:48:44,880
here

2635
01:48:44,880 --> 01:48:48,000
that tells rust

2636
01:48:48,000 --> 01:48:51,360
that the thing that comes in the borrow

2637
01:48:51,360 --> 01:48:53,520
of that

2638
01:48:53,520 --> 01:48:56,560
and let's let's actually use our words

2639
01:48:56,560 --> 01:49:00,560
the lifetime of that borrow the meaning

2640
01:49:00,560 --> 01:49:03,440
i'm borrowing something but the owner of

2641
01:49:03,440 --> 01:49:04,880
that

2642
01:49:04,880 --> 01:49:06,960
says it will live for a certain amount

2643
01:49:06,960 --> 01:49:07,920
of time

2644
01:49:07,920 --> 01:49:09,679
right the owner has guaranteed a certain

2645
01:49:09,679 --> 01:49:13,040
amount of life lifetime for that object

2646
01:49:13,040 --> 01:49:14,960
and because that owner has to delete it

2647
01:49:14,960 --> 01:49:17,040
at the end of the function

2648
01:49:17,040 --> 01:49:18,880
we know that is how long it's going to

2649
01:49:18,880 --> 01:49:21,360
live right so anything

2650
01:49:21,360 --> 01:49:25,920
that happens has to be

2651
01:49:25,920 --> 01:49:28,960
done and dusted by the time that owner

2652
01:49:28,960 --> 01:49:31,760
is done owning the object if it doesn't

2653
01:49:31,760 --> 01:49:33,119
give it up anywhere else like if it

2654
01:49:33,119 --> 01:49:35,440
stays owner the whole time

2655
01:49:35,440 --> 01:49:39,840
that's when we know that that

2656
01:49:39,840 --> 01:49:41,760
that value is gone it will be deleted

2657
01:49:41,760 --> 01:49:44,400
and destroyed

2658
01:49:44,480 --> 01:49:48,400
that's the lifetime of

2659
01:49:48,400 --> 01:49:51,360
of that object and when we say a borrow

2660
01:49:51,360 --> 01:49:52,480
has a lifetime

2661
01:49:52,480 --> 01:49:55,679
we're saying the borrow

2662
01:49:55,679 --> 01:49:58,480
has kind of a set of information along

2663
01:49:58,480 --> 01:49:59,679
with it

2664
01:49:59,679 --> 01:50:02,800
that says how long

2665
01:50:02,800 --> 01:50:05,920
again that struct or you know that value

2666
01:50:05,920 --> 01:50:06,880
behind the scenes

2667
01:50:06,880 --> 01:50:10,239
how long that will be available to us

2668
01:50:10,239 --> 01:50:13,199
so if we try to do something with it

2669
01:50:13,199 --> 01:50:14,400
afterwards

2670
01:50:14,400 --> 01:50:16,880
like the type checker that more

2671
01:50:16,880 --> 01:50:18,800
specifically the borrower checker

2672
01:50:18,800 --> 01:50:21,920
will say oh nope nope lifetimes don't

2673
01:50:21,920 --> 01:50:22,560
match

2674
01:50:22,560 --> 01:50:24,800
you're trying to borrow this thing for

2675
01:50:24,800 --> 01:50:26,639
way longer than it actually is going to

2676
01:50:26,639 --> 01:50:27,520
live

2677
01:50:27,520 --> 01:50:30,000
so you need something you need some way

2678
01:50:30,000 --> 01:50:31,040
of telling me that

2679
01:50:31,040 --> 01:50:34,400
what you're doing is actually okay

2680
01:50:35,360 --> 01:50:38,000
let's see this let's actually expand

2681
01:50:38,000 --> 01:50:38,960
name out

2682
01:50:38,960 --> 01:50:41,599
so we can see what name is doing under

2683
01:50:41,599 --> 01:50:44,239
the surface

2684
01:50:47,280 --> 01:50:50,960
so we'll say um tick

2685
01:50:50,960 --> 01:50:54,080
so we saw a t before or you know some

2686
01:50:54,080 --> 01:50:57,599
some type variable before

2687
01:50:57,599 --> 01:51:00,960
like t is common for type variables tick

2688
01:51:00,960 --> 01:51:04,400
a or tick and then sum name

2689
01:51:04,400 --> 01:51:07,840
is the name of a lifetime

2690
01:51:07,920 --> 01:51:10,400
and again that lifetime is how long the

2691
01:51:10,400 --> 01:51:11,199
underlying

2692
01:51:11,199 --> 01:51:14,239
thing will live

2693
01:51:19,360 --> 01:51:21,920
that is what's actually happening

2694
01:51:21,920 --> 01:51:24,639
underneath the surface

2695
01:51:24,639 --> 01:51:28,800
so let's let's work through this

2696
01:51:29,599 --> 01:51:32,719
rust has seen that something can

2697
01:51:32,719 --> 01:51:35,920
comes in with a lifetime tick a

2698
01:51:35,920 --> 01:51:38,480
we've actually given it a name now in

2699
01:51:38,480 --> 01:51:39,599
before

2700
01:51:39,599 --> 01:51:41,520
that was kind of hidden underneath the

2701
01:51:41,520 --> 01:51:42,800
surface

2702
01:51:42,800 --> 01:51:45,920
and rust was implying this for us and it

2703
01:51:45,920 --> 01:51:47,679
saves typing it's great

2704
01:51:47,679 --> 01:51:49,599
i think once you understand the

2705
01:51:49,599 --> 01:51:52,239
mechanics of how this works

2706
01:51:52,239 --> 01:51:55,280
then cool no worries

2707
01:51:55,280 --> 01:51:57,280
but if you're not quite up to that point

2708
01:51:57,280 --> 01:51:59,280
it can

2709
01:51:59,280 --> 01:52:03,199
it can seem a little bit magic that

2710
01:52:03,199 --> 01:52:05,360
okay i'm just starting to understand

2711
01:52:05,360 --> 01:52:07,199
ownership how does it know when things

2712
01:52:07,199 --> 01:52:07,920
are borrowed

2713
01:52:07,920 --> 01:52:11,040
for how long and what's going on

2714
01:52:11,040 --> 01:52:14,560
sorry let's actually look at this

2715
01:52:14,960 --> 01:52:18,719
we are saying that the value that's

2716
01:52:18,719 --> 01:52:20,480
coming in itself

2717
01:52:20,480 --> 01:52:23,760
is borrowed yeah we knew that

2718
01:52:23,760 --> 01:52:26,719
but the underlying thing that we're

2719
01:52:26,719 --> 01:52:27,920
borrowing

2720
01:52:27,920 --> 01:52:31,920
lives for some lifetime

2721
01:52:31,920 --> 01:52:34,159
we've given it a name now called tick a

2722
01:52:34,159 --> 01:52:35,360
which just means

2723
01:52:35,360 --> 01:52:38,719
some lifetime called tick a just like

2724
01:52:38,719 --> 01:52:41,840
when we say a type t and a generic

2725
01:52:41,840 --> 01:52:44,639
we're saying some type t we don't know

2726
01:52:44,639 --> 01:52:46,639
what it is

2727
01:52:46,639 --> 01:52:48,719
in this case we're saying some lifetime

2728
01:52:48,719 --> 01:52:50,800
tick a we don't know how long that will

2729
01:52:50,800 --> 01:52:52,239
be

2730
01:52:52,239 --> 01:52:54,560
the promise that we're making if you

2731
01:52:54,560 --> 01:52:56,480
will

2732
01:52:56,480 --> 01:52:59,520
to the compiler is that what we're

2733
01:52:59,520 --> 01:53:01,679
returning

2734
01:53:01,679 --> 01:53:04,880
lives the exact same amount of time

2735
01:53:04,880 --> 01:53:08,639
as self right tick a

2736
01:53:08,639 --> 01:53:10,639
so we're the thing that comes out is

2737
01:53:10,639 --> 01:53:11,679
borrowed

2738
01:53:11,679 --> 01:53:13,440
and the underlying thing that is

2739
01:53:13,440 --> 01:53:14,880
borrowed lives for

2740
01:53:14,880 --> 01:53:17,280
take a lifetime right just like the

2741
01:53:17,280 --> 01:53:18,159
thing that comes

2742
01:53:18,159 --> 01:53:20,400
that came in is borrowed and lives for

2743
01:53:20,400 --> 01:53:23,520
take a lifetime

2744
01:53:25,360 --> 01:53:28,480
now if you take a second and think about

2745
01:53:28,480 --> 01:53:30,639
this

2746
01:53:30,639 --> 01:53:34,080
i think you'll see why this is true

2747
01:53:34,080 --> 01:53:37,760
and once you see it i think

2748
01:53:37,760 --> 01:53:39,679
some of the ownership systems some of

2749
01:53:39,679 --> 01:53:41,119
the borrower system

2750
01:53:41,119 --> 01:53:44,560
will start to come into view

2751
01:53:44,719 --> 01:53:46,480
the structure that's coming in that

2752
01:53:46,480 --> 01:53:48,639
employee structure

2753
01:53:48,639 --> 01:53:51,440
right we said before that when we when

2754
01:53:51,440 --> 01:53:52,080
we gave

2755
01:53:52,080 --> 01:53:54,560
name that string we gave that string to

2756
01:53:54,560 --> 01:53:55,920
employee

2757
01:53:55,920 --> 01:54:00,560
it owns name right

2758
01:54:00,560 --> 01:54:03,040
so everything an employee all the fields

2759
01:54:03,040 --> 01:54:03,679
are

2760
01:54:03,679 --> 01:54:07,199
are owned by employee in our example

2761
01:54:07,199 --> 01:54:10,159
just to kind of remind ourselves right

2762
01:54:10,159 --> 01:54:12,239
no ampersands or anything

2763
01:54:12,239 --> 01:54:15,679
it owns all those values

2764
01:54:16,159 --> 01:54:19,520
when we have self

2765
01:54:19,520 --> 01:54:22,639
right self is one of these employees and

2766
01:54:22,639 --> 01:54:23,679
we're borrowing it

2767
01:54:23,679 --> 01:54:27,360
right take a lifetime right so

2768
01:54:27,360 --> 01:54:30,159
some owner somewhere is going to let

2769
01:54:30,159 --> 01:54:31,679
that employee value

2770
01:54:31,679 --> 01:54:36,000
live for take a lifetime

2771
01:54:36,000 --> 01:54:39,760
inside of this employee is that string

2772
01:54:39,760 --> 01:54:43,040
and that string lives for the exact same

2773
01:54:43,040 --> 01:54:44,320
amount of time

2774
01:54:44,320 --> 01:54:48,239
as employee why because employee owns

2775
01:54:48,239 --> 01:54:53,760
the name all right you see that

2776
01:54:53,840 --> 01:54:58,400
i think once you start to see where

2777
01:54:58,400 --> 01:55:00,800
this ownership is happening or where the

2778
01:55:00,800 --> 01:55:02,639
the lifetime is happening in this

2779
01:55:02,639 --> 01:55:05,760
that when employee is deleted

2780
01:55:05,760 --> 01:55:08,960
string is deleted basically at the exact

2781
01:55:08,960 --> 01:55:11,920
same time right we're just gonna as we

2782
01:55:11,920 --> 01:55:12,800
drop one

2783
01:55:12,800 --> 01:55:15,360
we drop all the contents of that string

2784
01:55:15,360 --> 01:55:15,920
so

2785
01:55:15,920 --> 01:55:17,520
all of that goes away all at the same

2786
01:55:17,520 --> 01:55:19,520
time and that's because

2787
01:55:19,520 --> 01:55:22,880
employee owns that string that name

2788
01:55:22,880 --> 01:55:26,000
field that string

2789
01:55:26,159 --> 01:55:29,360
so if we look back here we can kind of

2790
01:55:29,360 --> 01:55:30,239
see

2791
01:55:30,239 --> 01:55:32,400
all of that machinery that's kind of

2792
01:55:32,400 --> 01:55:34,639
behind the scenes

2793
01:55:34,639 --> 01:55:37,440
now coming to the surface you give me an

2794
01:55:37,440 --> 01:55:38,560
employee

2795
01:55:38,560 --> 01:55:41,840
i can safely reach into that employee

2796
01:55:41,840 --> 01:55:44,880
and refer to some piece of it i can

2797
01:55:44,880 --> 01:55:46,800
borrow some piece of it

2798
01:55:46,800 --> 01:55:50,320
if i borrow a piece of it the lifetime

2799
01:55:50,320 --> 01:55:51,280
of that piece

2800
01:55:51,280 --> 01:55:55,679
has to be the same as the whole thing

2801
01:55:55,679 --> 01:55:59,520
because we know employee owns that

2802
01:55:59,520 --> 01:56:02,080
that piece

2803
01:56:03,199 --> 01:56:05,920
any questions

2804
01:56:13,520 --> 01:56:16,560
cool yeah i think

2805
01:56:16,560 --> 01:56:20,000
once you wrap your head around this

2806
01:56:20,000 --> 01:56:25,199
right i think it helps you unlock how um

2807
01:56:26,840 --> 01:56:29,760
yep once yeah once you wrap your head

2808
01:56:29,760 --> 01:56:30,639
around it

2809
01:56:30,639 --> 01:56:32,960
uh i think it unlocks how all these

2810
01:56:32,960 --> 01:56:35,119
pieces start to fit together

2811
01:56:35,119 --> 01:56:37,119
uh and the question andy was asking

2812
01:56:37,119 --> 01:56:38,800
would lifetime illusion work instead of

2813
01:56:38,800 --> 01:56:41,040
ticket yeah so what we used before

2814
01:56:41,040 --> 01:56:43,520
is called lifetime religion so instead

2815
01:56:43,520 --> 01:56:45,119
of writing it like this

2816
01:56:45,119 --> 01:56:48,400
and we wrote it like this

2817
01:56:48,560 --> 01:56:50,320
and you'll you'll remember this is

2818
01:56:50,320 --> 01:56:51,760
actually what we did

2819
01:56:51,760 --> 01:56:55,199
originally right but we didn't know yet

2820
01:56:55,199 --> 01:56:56,320
what was happening

2821
01:56:56,320 --> 01:57:00,320
beneath the surface so when you see this

2822
01:57:00,320 --> 01:57:03,840
imagine what i showed you before

2823
01:57:03,840 --> 01:57:06,719
right so the lifetime of self and the

2824
01:57:06,719 --> 01:57:09,520
lifetime of this string slice going out

2825
01:57:09,520 --> 01:57:11,920
are going to be matched that's that's

2826
01:57:11,920 --> 01:57:13,760
lifetime religion and you can kind of

2827
01:57:13,760 --> 01:57:16,080
google it and kind of go read about it

2828
01:57:16,080 --> 01:57:16,800
but it's

2829
01:57:16,800 --> 01:57:19,360
something that the compiler is doing to

2830
01:57:19,360 --> 01:57:20,159
save you

2831
01:57:20,159 --> 01:57:24,000
from having to type all of the lifetimes

2832
01:57:24,000 --> 01:57:28,159
out manually it's kind of like you know

2833
01:57:28,159 --> 01:57:30,000
like a language may have type inference

2834
01:57:30,000 --> 01:57:33,760
to infer what the type of variable is

2835
01:57:33,760 --> 01:57:35,599
lifetime religion is like lifetime

2836
01:57:35,599 --> 01:57:37,760
inference

2837
01:57:37,760 --> 01:57:39,440
that makes sense right so it's kind of

2838
01:57:39,440 --> 01:57:40,880
putting tick a and tick a

2839
01:57:40,880 --> 01:57:45,920
here for you without you having to do it

2840
01:57:45,920 --> 01:57:47,599
but i think it's i think it's good to

2841
01:57:47,599 --> 01:57:48,960
actually

2842
01:57:48,960 --> 01:57:52,480
type out um what would be there

2843
01:57:52,480 --> 01:57:55,599
without the inference because that lets

2844
01:57:55,599 --> 01:57:56,880
you see

2845
01:57:56,880 --> 01:58:06,560
how these things are connected

2846
01:58:06,560 --> 01:58:09,280
and then once you get used to it then by

2847
01:58:09,280 --> 01:58:10,560
all means

2848
01:58:10,560 --> 01:58:13,119
by all means use illusion don't save

2849
01:58:13,119 --> 01:58:14,560
yourself the typing and save yourself

2850
01:58:14,560 --> 01:58:16,400
the complexity a bit

2851
01:58:16,400 --> 01:58:18,960
but at least understand what's going on

2852
01:58:18,960 --> 01:58:21,840
beneath the surface

2853
01:58:24,880 --> 01:58:26,800
so we have a question russ can't figure

2854
01:58:26,800 --> 01:58:29,360
out the minimal lifetime of all borrowed

2855
01:58:29,360 --> 01:58:30,800
parameters and assign

2856
01:58:30,800 --> 01:58:33,840
this to the result to be safe yeah in

2857
01:58:33,840 --> 01:58:34,080
the

2858
01:58:34,080 --> 01:58:37,040
general case

2859
01:58:37,599 --> 01:58:41,440
you cannot imply you can't

2860
01:58:41,440 --> 01:58:43,520
infer everything just like in the

2861
01:58:43,520 --> 01:58:45,840
general case for type inference

2862
01:58:45,840 --> 01:58:48,400
there'll be times when you can't right

2863
01:58:48,400 --> 01:58:50,719
you're just in an ambiguous case

2864
01:58:50,719 --> 01:58:54,560
just you just don't know which you mean

2865
01:58:54,560 --> 01:58:57,520
and in those cases you do have to do the

2866
01:58:57,520 --> 01:58:59,360
explicit

2867
01:58:59,360 --> 01:59:02,480
lifetime notation

2868
01:59:02,480 --> 01:59:05,520
just like you would with like a generic

2869
01:59:05,520 --> 01:59:08,960
or what's a good one

2870
01:59:08,960 --> 01:59:11,599
there's a method in rus called collect

2871
01:59:11,599 --> 01:59:12,400
and collect

2872
01:59:12,400 --> 01:59:14,560
can collect into different types of

2873
01:59:14,560 --> 01:59:15,679
things

2874
01:59:15,679 --> 01:59:18,639
so type inference is ambiguous if you

2875
01:59:18,639 --> 01:59:19,920
call collect it's like i

2876
01:59:19,920 --> 01:59:21,840
i i don't know what you're trying to

2877
01:59:21,840 --> 01:59:23,040
collect well

2878
01:59:23,040 --> 01:59:24,960
what are you trying to create and you

2879
01:59:24,960 --> 01:59:26,880
have to give it an explicit type

2880
01:59:26,880 --> 01:59:27,679
annotation

2881
01:59:27,679 --> 01:59:30,159
to say what to collect so that's an

2882
01:59:30,159 --> 01:59:31,040
example of

2883
01:59:31,040 --> 01:59:32,639
sometimes type inference just doesn't

2884
01:59:32,639 --> 01:59:34,880
work right and you have to

2885
01:59:34,880 --> 01:59:37,040
you have to use the explicit form the

2886
01:59:37,040 --> 01:59:38,239
same thing is going to be true when you

2887
01:59:38,239 --> 01:59:40,320
start getting into borrow checking

2888
01:59:40,320 --> 01:59:43,280
and borrow like annotations for

2889
01:59:43,280 --> 01:59:44,480
lifetimes

2890
01:59:44,480 --> 01:59:47,119
sometimes it can imply it it can infer

2891
01:59:47,119 --> 01:59:48,719
it i mean sometimes it can infer it and

2892
01:59:48,719 --> 01:59:52,159
sometimes you have to be explicit

2893
01:59:52,560 --> 01:59:55,679
yep and as we'll see

2894
01:59:55,679 --> 01:59:56,880
well i don't know if we'll get into it

2895
01:59:56,880 --> 01:59:58,480
in this stream maybe we'll do another

2896
01:59:58,480 --> 01:59:58,880
stream

2897
01:59:58,880 --> 02:00:02,080
it's like a follow-up but strucks

2898
02:00:02,080 --> 02:00:06,560
themselves so here employee was owned

2899
02:00:06,560 --> 02:00:09,440
that employee owns this string but you

2900
02:00:09,440 --> 02:00:10,840
can imagine that

2901
02:00:10,840 --> 02:00:14,080
employee could own a borrow

2902
02:00:14,080 --> 02:00:18,480
of you know of a string a borrow of uh

2903
02:00:18,880 --> 02:00:22,080
a oh i'm blanking on the name that

2904
02:00:22,080 --> 02:00:25,520
the anster basically

2905
02:00:25,679 --> 02:00:27,199
so we could it could own something like

2906
02:00:27,199 --> 02:00:29,040
that and in that case

2907
02:00:29,040 --> 02:00:31,599
the struct needs to hold on to that

2908
02:00:31,599 --> 02:00:32,560
information

2909
02:00:32,560 --> 02:00:35,360
right as part of its type just like a

2910
02:00:35,360 --> 02:00:36,480
type parameter

2911
02:00:36,480 --> 02:00:38,840
it would need a lifetime parameter as

2912
02:00:38,840 --> 02:00:40,239
well

2913
02:00:40,239 --> 02:00:42,320
right so it can't there are some cases

2914
02:00:42,320 --> 02:00:44,400
where you do have to be explicit

2915
02:00:44,400 --> 02:00:47,599
and then in that explicit information

2916
02:00:47,599 --> 02:00:50,159
that's where you know the rust compiler

2917
02:00:50,159 --> 02:00:51,679
will will use that

2918
02:00:51,679 --> 02:00:54,719
to type check your code or check the

2919
02:00:54,719 --> 02:00:57,199
lifetimes of the code

2920
02:00:57,199 --> 02:01:00,239
cool any other questions

2921
02:01:02,719 --> 02:01:05,040
all right i think the last thing that i

2922
02:01:05,040 --> 02:01:07,440
want to do before we call it

2923
02:01:07,440 --> 02:01:11,520
is to just point you at a couple of

2924
02:01:11,520 --> 02:01:14,159
things that you can use as you start to

2925
02:01:14,159 --> 02:01:15,520
explore

2926
02:01:15,520 --> 02:01:18,800
the borrower checking

2927
02:01:18,800 --> 02:01:22,159
system a bit if you do get stuck

2928
02:01:22,159 --> 02:01:25,679
um let me just call these out real quick

2929
02:01:25,679 --> 02:01:28,239
oh someone asked to show adding a

2930
02:01:28,239 --> 02:01:29,199
dependency

2931
02:01:29,199 --> 02:01:32,080
let's let's go do that real quick so

2932
02:01:32,080 --> 02:01:34,960
cargo tommel

2933
02:01:35,119 --> 02:01:38,880
has these has this dependency

2934
02:01:39,679 --> 02:01:43,119
portion of the config file

2935
02:01:43,119 --> 02:01:46,320
and in this dependency section

2936
02:01:46,320 --> 02:01:48,800
i can just add dependencies into it and

2937
02:01:48,800 --> 02:01:50,239
as i do it will go

2938
02:01:50,239 --> 02:01:52,560
and fetch these for me there's one i'm

2939
02:01:52,560 --> 02:01:53,520
going to use now

2940
02:01:53,520 --> 02:01:57,040
called parking lot

2941
02:01:57,040 --> 02:01:58,960
incidentally actually let me pull this

2942
02:01:58,960 --> 02:02:01,520
up real quick

2943
02:02:02,840 --> 02:02:06,400
right you can find these by going to

2944
02:02:06,400 --> 02:02:09,280
crates.io

2945
02:02:11,440 --> 02:02:14,080
and this is the package registry make

2946
02:02:14,080 --> 02:02:15,280
this a little bit bigger so you can see

2947
02:02:15,280 --> 02:02:16,960
it

2948
02:02:16,960 --> 02:02:20,080
see that okay cool um

2949
02:02:20,080 --> 02:02:22,960
i can search for things here so example

2950
02:02:22,960 --> 02:02:23,520
if i

2951
02:02:23,520 --> 02:02:26,800
tried searching for parking lot you just

2952
02:02:26,800 --> 02:02:27,920
have to kind of

2953
02:02:27,920 --> 02:02:29,440
this one in particular you just have to

2954
02:02:29,440 --> 02:02:31,119
know to look for it

2955
02:02:31,119 --> 02:02:32,719
but there's plenty of stuff that you can

2956
02:02:32,719 --> 02:02:35,840
just go to the main site

2957
02:02:35,840 --> 02:02:37,599
and i do this sometimes just kind of see

2958
02:02:37,599 --> 02:02:39,520
what's what's

2959
02:02:39,520 --> 02:02:43,920
popular what's newly updated what are

2960
02:02:43,920 --> 02:02:45,280
new crates

2961
02:02:45,280 --> 02:02:46,800
and then you can look for different

2962
02:02:46,800 --> 02:02:48,320
types of things like say you're into

2963
02:02:48,320 --> 02:02:49,199
crypto or

2964
02:02:49,199 --> 02:02:52,400
you're into async or cli you know

2965
02:02:52,400 --> 02:02:53,199
whatever

2966
02:02:53,199 --> 02:02:54,960
you're a windows programmer then you can

2967
02:02:54,960 --> 02:02:56,560
click in and get

2968
02:02:56,560 --> 02:02:58,880
a set of the creates that you might use

2969
02:02:58,880 --> 02:03:00,080
as a windows programmer

2970
02:03:00,080 --> 02:03:02,480
so this is really handy place to start

2971
02:03:02,480 --> 02:03:03,920
to find

2972
02:03:03,920 --> 02:03:06,560
what dependencies you could use in your

2973
02:03:06,560 --> 02:03:07,199
system

2974
02:03:07,199 --> 02:03:10,400
in your application the one we're going

2975
02:03:10,400 --> 02:03:12,320
to use is parking lot

2976
02:03:12,320 --> 02:03:15,360
in our example and parking lot what it

2977
02:03:15,360 --> 02:03:16,159
does

2978
02:03:16,159 --> 02:03:19,679
once this pulls up i have to hit enter

2979
02:03:19,679 --> 02:03:23,599
apparently who knew um

2980
02:03:23,599 --> 02:03:27,119
yeah parking lot is kind of uh

2981
02:03:27,119 --> 02:03:32,320
easy to use lock so it's a mutex

2982
02:03:32,320 --> 02:03:34,239
and it's got some other stuff in it but

2983
02:03:34,239 --> 02:03:37,840
we'll just use the lock part of it

2984
02:03:39,040 --> 02:03:42,719
so to add that to our application

2985
02:03:42,719 --> 02:03:45,679
what we need to do is to tell cargo

2986
02:03:45,679 --> 02:03:48,800
which one we want to use

2987
02:03:49,199 --> 02:03:51,520
i've got oh that is something i did not

2988
02:03:51,520 --> 02:03:52,880
talk about let's talk about that real

2989
02:03:52,880 --> 02:03:53,280
quick

2990
02:03:53,280 --> 02:03:57,119
a little sidebar i used a better toml

2991
02:03:57,119 --> 02:04:00,239
to give coloring and crates

2992
02:04:00,239 --> 02:04:03,679
crates being these dependencies

2993
02:04:03,679 --> 02:04:06,480
are called crates

2994
02:04:06,800 --> 02:04:08,639
and this plugin for vs code and there

2995
02:04:08,639 --> 02:04:12,320
might be similar things for intellij

2996
02:04:12,320 --> 02:04:15,280
tell me which ones are up to date and

2997
02:04:15,280 --> 02:04:16,480
what their versions are

2998
02:04:16,480 --> 02:04:17,679
so i don't have to remember what the

2999
02:04:17,679 --> 02:04:19,040
version is i just have to remember oh

3000
02:04:19,040 --> 02:04:20,639
yeah there's one called parking lot i

3001
02:04:20,639 --> 02:04:21,920
type it in

3002
02:04:21,920 --> 02:04:24,079
and i type some quotes where i can auto

3003
02:04:24,079 --> 02:04:25,920
complete something and says hey

3004
02:04:25,920 --> 02:04:28,960
the latest is 0.11.1 great

3005
02:04:28,960 --> 02:04:32,400
cool hit save and you can see that it's

3006
02:04:32,400 --> 02:04:33,199
going and

3007
02:04:33,199 --> 02:04:36,400
cargo is um running in the background

3008
02:04:36,400 --> 02:04:39,119
and we're finding that dependency

3009
02:04:39,119 --> 02:04:40,159
downloading it

3010
02:04:40,159 --> 02:04:44,719
and checking it so i should now have

3011
02:04:44,719 --> 02:04:47,840
uh let me close this

3012
02:04:47,920 --> 02:04:50,320
i should now have the ability to call

3013
02:04:50,320 --> 02:04:52,719
into parking lot

3014
02:04:52,719 --> 02:04:56,079
so here at the top i use standard air

3015
02:04:56,079 --> 02:04:58,000
error so this is actually reaching into

3016
02:04:58,000 --> 02:04:59,440
the standard crate

3017
02:04:59,440 --> 02:05:00,960
and getting values out of the standard

3018
02:05:00,960 --> 02:05:02,639
crate

3019
02:05:02,639 --> 02:05:05,679
i can use parking lot in the same way

3020
02:05:05,679 --> 02:05:09,280
oops parking i type

3021
02:05:09,280 --> 02:05:11,360
touched it in the wrong place parking

3022
02:05:11,360 --> 02:05:12,400
lot

3023
02:05:12,400 --> 02:05:17,199
lock which lock do i want

3024
02:05:17,199 --> 02:05:20,400
parking lot oh probably mutex

3025
02:05:20,400 --> 02:05:23,440
yeah i want mutex

3026
02:05:23,760 --> 02:05:26,320
i think yeah there's actually a few

3027
02:05:26,320 --> 02:05:29,040
different ones that we could use

3028
02:05:29,040 --> 02:05:30,880
let's just use mutex i think that's what

3029
02:05:30,880 --> 02:05:34,320
i wanted to use

3030
02:05:34,320 --> 02:05:36,320
and so that's how you go get a

3031
02:05:36,320 --> 02:05:37,520
dependency

3032
02:05:37,520 --> 02:05:40,719
and then start using that dependency

3033
02:05:40,719 --> 02:05:44,159
so i've got i now have a mutex structure

3034
02:05:44,159 --> 02:05:44,800
that i can

3035
02:05:44,800 --> 02:05:48,400
start to use so let's say that i wanted

3036
02:05:48,400 --> 02:05:49,360
to create

3037
02:05:49,360 --> 02:05:52,639
a um

3038
02:05:52,719 --> 02:05:56,000
like a a thread safe version of a

3039
02:05:56,000 --> 02:05:59,280
shared employee and there's

3040
02:05:59,280 --> 02:06:00,880
different ways that we can do that but

3041
02:06:00,880 --> 02:06:02,960
one one of the easiest ways

3042
02:06:02,960 --> 02:06:06,000
is to just put a lock around it

3043
02:06:06,000 --> 02:06:08,320
and so any thread that has to use it has

3044
02:06:08,320 --> 02:06:09,520
to unlock it first

3045
02:06:09,520 --> 02:06:12,639
to use it so we'll make a

3046
02:06:12,639 --> 02:06:16,719
locked employee

3047
02:06:16,719 --> 02:06:19,760
and we'll say mutex new

3048
02:06:19,760 --> 02:06:22,960
i believe i think that's right and the

3049
02:06:22,960 --> 02:06:25,520
employee

3050
02:06:26,560 --> 02:06:30,159
right so now we have a locked version

3051
02:06:30,159 --> 02:06:31,760
i apologize if you can't see that let me

3052
02:06:31,760 --> 02:06:34,480
just shrink that up

3053
02:06:35,199 --> 02:06:38,239
right so we have a now

3054
02:06:38,239 --> 02:06:40,639
an employee we created an employee and

3055
02:06:40,639 --> 02:06:42,800
then we gave ownership of that employee

3056
02:06:42,800 --> 02:06:46,000
to the mutex so this should look

3057
02:06:46,000 --> 02:06:48,320
once i hit save this should look pretty

3058
02:06:48,320 --> 02:06:49,040
familiar

3059
02:06:49,040 --> 02:06:52,159
hey by the way you moved it

3060
02:06:52,159 --> 02:06:55,520
can't do that and yeah yeah we did

3061
02:06:55,520 --> 02:06:57,840
we moved it we gave it gave an employee

3062
02:06:57,840 --> 02:07:00,480
to the mutex now the mutex is the one

3063
02:07:00,480 --> 02:07:04,239
that owns that employee to get the value

3064
02:07:04,239 --> 02:07:05,360
back out

3065
02:07:05,360 --> 02:07:09,360
we need to actually lock the value

3066
02:07:09,360 --> 02:07:12,719
so we'll say um you wouldn't

3067
02:07:12,719 --> 02:07:14,400
do this all in one function but i'm just

3068
02:07:14,400 --> 02:07:16,560
kind of showing it here for brevity

3069
02:07:16,560 --> 02:07:19,760
so our unlocked

3070
02:07:19,840 --> 02:07:23,199
employee equals blocked

3071
02:07:23,199 --> 02:07:27,280
employee dot

3072
02:07:27,520 --> 02:07:31,360
uh unlock

3073
02:07:31,360 --> 02:07:34,560
something uh

3074
02:07:34,560 --> 02:07:36,480
what am i actually trying to call here

3075
02:07:36,480 --> 02:07:39,199
so we made the mutex

3076
02:07:39,199 --> 02:07:42,560
i think it's lock try

3077
02:07:42,560 --> 02:07:46,000
lock option mutex

3078
02:07:46,000 --> 02:07:49,280
guard raw mutex hmm

3079
02:07:49,280 --> 02:07:50,560
i'm trying to do this off the top of my

3080
02:07:50,560 --> 02:07:52,639
head and i'm kind of blanking on how

3081
02:07:52,639 --> 02:07:54,000
this works to be totally honest

3082
02:07:54,000 --> 02:07:56,880
with you i want to say that there's a

3083
02:07:56,880 --> 02:07:58,079
lock

3084
02:07:58,079 --> 02:08:01,360
and then you can just use it yeah

3085
02:08:01,360 --> 02:08:08,079
maybe you can just use it at this point

3086
02:08:08,079 --> 02:08:11,520
yep that's right

3087
02:08:11,520 --> 02:08:14,000
all right so cargo is going while we're

3088
02:08:14,000 --> 02:08:15,599
building

3089
02:08:15,599 --> 02:08:17,520
you know in the background because we

3090
02:08:17,520 --> 02:08:18,639
have these other things

3091
02:08:18,639 --> 02:08:20,480
doing the analysis it's already gone and

3092
02:08:20,480 --> 02:08:21,920
fetched it if you hadn't done that you

3093
02:08:21,920 --> 02:08:23,599
would see it download

3094
02:08:23,599 --> 02:08:26,800
the the

3095
02:08:26,800 --> 02:08:30,639
parking lot crate and then these are

3096
02:08:30,639 --> 02:08:33,840
the steps to build parking lot and now

3097
02:08:33,840 --> 02:08:37,840
it runs and this is

3098
02:08:38,239 --> 02:08:40,079
actually doing these additional steps

3099
02:08:40,079 --> 02:08:42,000
right so we created a mutex

3100
02:08:42,000 --> 02:08:43,840
and then we blocked the mutex and got

3101
02:08:43,840 --> 02:08:46,079
the employee back out

3102
02:08:46,079 --> 02:08:50,239
so this this allows us again to have a

3103
02:08:50,239 --> 02:08:51,360
thread save

3104
02:08:51,360 --> 02:08:54,480
copy of the employee that multiple

3105
02:08:54,480 --> 02:08:55,840
threads can share

3106
02:08:55,840 --> 02:08:57,599
so i just kind of want to show this

3107
02:08:57,599 --> 02:08:58,960
there is a

3108
02:08:58,960 --> 02:09:02,639
a lock or mutex in the standard library

3109
02:09:02,639 --> 02:09:04,320
as well you can use you know it's

3110
02:09:04,320 --> 02:09:05,840
totally fine to use that one i just use

3111
02:09:05,840 --> 02:09:07,440
the parking lot one because there's

3112
02:09:07,440 --> 02:09:10,800
one fewer steps in the code

3113
02:09:10,800 --> 02:09:12,880
in the one in the standard library you

3114
02:09:12,880 --> 02:09:14,480
would need to do a pattern match to make

3115
02:09:14,480 --> 02:09:15,760
sure that the lock

3116
02:09:15,760 --> 02:09:18,719
locked successfully or failed and then

3117
02:09:18,719 --> 02:09:21,840
at that point use the value

3118
02:09:22,239 --> 02:09:23,599
but yeah so that's one thing that you

3119
02:09:23,599 --> 02:09:25,360
can do is to use

3120
02:09:25,360 --> 02:09:28,719
the locks and then the

3121
02:09:28,719 --> 02:09:32,239
another trick is to use arc

3122
02:09:32,239 --> 02:09:35,679
so let me just show that one real quick

3123
02:09:36,880 --> 02:09:38,560
again we're going to give up ownership

3124
02:09:38,560 --> 02:09:42,159
of employee to something else

3125
02:09:43,040 --> 02:09:47,920
so let's say reference counted

3126
02:09:48,159 --> 02:09:51,360
if i say arc new

3127
02:09:51,360 --> 02:09:53,920
employee

3128
02:09:54,480 --> 02:09:57,599
and we get an error message and says hey

3129
02:09:57,599 --> 02:10:00,480
there's a fix for this i kind of like

3130
02:10:00,480 --> 02:10:01,920
that uh

3131
02:10:01,920 --> 02:10:04,000
but vs code and rust analyzer do this

3132
02:10:04,000 --> 02:10:05,280
for you so i don't always have to

3133
02:10:05,280 --> 02:10:05,760
remember

3134
02:10:05,760 --> 02:10:07,119
where this thing goes sometimes it's

3135
02:10:07,119 --> 02:10:09,199
hard to remember where some of these

3136
02:10:09,199 --> 02:10:12,560
these values live these structs live

3137
02:10:12,560 --> 02:10:14,800
so it's going to import standard sync

3138
02:10:14,800 --> 02:10:16,000
arc

3139
02:10:16,000 --> 02:10:18,880
and when i do that

3140
02:10:19,679 --> 02:10:22,000
i get standard i get the sync arc here

3141
02:10:22,000 --> 02:10:23,840
at the top

3142
02:10:23,840 --> 02:10:27,440
and now i get this

3143
02:10:27,440 --> 02:10:30,719
atomic atomic reference count

3144
02:10:30,719 --> 02:10:32,880
i think that's what the a stands for but

3145
02:10:32,880 --> 02:10:35,360
this is something else that i can share

3146
02:10:35,360 --> 02:10:37,920
right so multiple threads can use this

3147
02:10:37,920 --> 02:10:38,400
and

3148
02:10:38,400 --> 02:10:39,920
it's going to behind the scenes every

3149
02:10:39,920 --> 02:10:41,599
time this is

3150
02:10:41,599 --> 02:10:45,440
you know cloned will increment

3151
02:10:45,440 --> 02:10:47,040
the count of the number of people

3152
02:10:47,040 --> 02:10:49,840
referring to it so you can safely know

3153
02:10:49,840 --> 02:10:53,599
when you can modify it or when you can't

3154
02:10:53,599 --> 02:10:56,639
because if more than one person's

3155
02:10:56,639 --> 02:10:57,360
looking at it

3156
02:10:57,360 --> 02:10:59,199
you know it's not safe to be modifying

3157
02:10:59,199 --> 02:11:00,480
it right there's

3158
02:11:00,480 --> 02:11:03,920
there's you know six eyes on this thing

3159
02:11:03,920 --> 02:11:06,159
uh if you start mutating it they're

3160
02:11:06,159 --> 02:11:06,960
gonna see

3161
02:11:06,960 --> 02:11:09,599
some kind of weird behavior and so in

3162
02:11:09,599 --> 02:11:10,400
rust

3163
02:11:10,400 --> 02:11:12,880
i kind of implied this before but let's

3164
02:11:12,880 --> 02:11:14,000
just kind of

3165
02:11:14,000 --> 02:11:18,800
say it out explicitly you can have

3166
02:11:18,800 --> 02:11:22,159
multiple borrows

3167
02:11:22,159 --> 02:11:25,679
of something if they're immutable

3168
02:11:25,679 --> 02:11:28,320
right so each borrow always sees the

3169
02:11:28,320 --> 02:11:28,800
same

3170
02:11:28,800 --> 02:11:31,199
value whenever they look at it for as

3171
02:11:31,199 --> 02:11:33,920
long as that borrower lives

3172
02:11:33,920 --> 02:11:35,920
so you can have multiple borrows so long

3173
02:11:35,920 --> 02:11:37,520
as they're immutable

3174
02:11:37,520 --> 02:11:40,320
if you have a mutable borrow you can

3175
02:11:40,320 --> 02:11:40,880
only have

3176
02:11:40,880 --> 02:11:44,320
one only one person is allowed to

3177
02:11:44,320 --> 02:11:45,199
observe

3178
02:11:45,199 --> 02:11:48,960
and mutate a value

3179
02:11:48,960 --> 02:11:52,560
and this gets you out of trouble of

3180
02:11:52,560 --> 02:11:54,400
all kinds of stuff more than we have

3181
02:11:54,400 --> 02:11:56,719
time to go for into in this stream

3182
02:11:56,719 --> 02:11:59,040
but that that's a simplifying assumption

3183
02:11:59,040 --> 02:12:00,880
that in the rust type system and the

3184
02:12:00,880 --> 02:12:02,159
ownership system

3185
02:12:02,159 --> 02:12:05,199
that's how they keep threads safe you

3186
02:12:05,199 --> 02:12:06,239
know

3187
02:12:06,239 --> 02:12:08,159
yeah sure you can share it but you can't

3188
02:12:08,159 --> 02:12:11,040
mutate it or if you mutate it

3189
02:12:11,040 --> 02:12:14,079
you need to only have one owner and the

3190
02:12:14,079 --> 02:12:16,719
tricks that using mutex

3191
02:12:16,719 --> 02:12:20,639
and arc give you are to how do you know

3192
02:12:20,639 --> 02:12:21,920
that there's only one owner

3193
02:12:21,920 --> 02:12:25,679
mutex lets you lock it now you have one

3194
02:12:25,679 --> 02:12:29,920
um one wave looking into it

3195
02:12:29,920 --> 02:12:32,000
right everyone that wants to look in has

3196
02:12:32,000 --> 02:12:33,199
to lock it first

3197
02:12:33,199 --> 02:12:35,360
only one person gets to win and that

3198
02:12:35,360 --> 02:12:36,560
person also

3199
02:12:36,560 --> 02:12:38,639
could get to mutate it right they're the

3200
02:12:38,639 --> 02:12:40,480
one owner or the one

3201
02:12:40,480 --> 02:12:41,760
i guess you could kind of say like the

3202
02:12:41,760 --> 02:12:43,760
one borrower

3203
02:12:43,760 --> 02:12:46,800
one mutable borrower so that's

3204
02:12:46,800 --> 02:12:49,119
why mutex works and then arc works by

3205
02:12:49,119 --> 02:12:50,480
doing this counting

3206
02:12:50,480 --> 02:12:53,440
so if you try to mutate and multiple

3207
02:12:53,440 --> 02:12:55,040
people have borrowed it

3208
02:12:55,040 --> 02:12:57,520
that will fail right so it's kind of

3209
02:12:57,520 --> 02:12:58,400
doing the same

3210
02:12:58,400 --> 02:13:01,920
kind of enforcement but it's enforcing

3211
02:13:01,920 --> 02:13:02,960
it at run time

3212
02:13:02,960 --> 02:13:05,920
right every time you peer into this arc

3213
02:13:05,920 --> 02:13:06,400
you have

3214
02:13:06,400 --> 02:13:08,480
you get a little reference count or

3215
02:13:08,480 --> 02:13:09,440
every time you own

3216
02:13:09,440 --> 02:13:11,119
a copy of this arc you get a reference

3217
02:13:11,119 --> 02:13:13,040
count and that reference count is what's

3218
02:13:13,040 --> 02:13:14,840
keeping you

3219
02:13:14,840 --> 02:13:17,599
safe okay i wanted to at least mention

3220
02:13:17,599 --> 02:13:18,880
those two they are a little bit more

3221
02:13:18,880 --> 02:13:20,079
advanced

3222
02:13:20,079 --> 02:13:21,599
but as you get into the borrowed

3223
02:13:21,599 --> 02:13:23,920
checking system

3224
02:13:23,920 --> 02:13:27,760
having tools like just cloning it

3225
02:13:27,760 --> 02:13:29,360
don't worry about the copies that's

3226
02:13:29,360 --> 02:13:31,119
always the option right you can always

3227
02:13:31,119 --> 02:13:32,000
do that

3228
02:13:32,000 --> 02:13:34,079
if you want to keep one value in memory

3229
02:13:34,079 --> 02:13:35,840
and say it's like a big object or

3230
02:13:35,840 --> 02:13:37,040
something that you really don't want

3231
02:13:37,040 --> 02:13:38,400
multiple copies of

3232
02:13:38,400 --> 02:13:41,199
you can use locking you can use arcs to

3233
02:13:41,199 --> 02:13:42,960
not have to worry

3234
02:13:42,960 --> 02:13:46,159
about really fine-tuning

3235
02:13:46,159 --> 02:13:48,000
all your all your lifetime annotations

3236
02:13:48,000 --> 02:13:50,400
everywhere you can use these other tools

3237
02:13:50,400 --> 02:13:54,719
to get going and to get working

